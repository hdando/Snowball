<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Warfare</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            width: 250px;
        }
        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        .stat-value {
            font-weight: bold;
        }
        .controls {
            font-size: 12px;
            margin-top: 10px;
            color: #aaa;
        }
        .floating-text {
            position: absolute;
            font-family: Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0px 0px 3px #000;
            pointer-events: none;
            opacity: 1;
            transform: translateY(0);
            transition: opacity 1s, transform 1s;
            z-index: 100;
        }
        
        /* Styles pour le cycle de jeu */
        .podium-screen {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(20,20,50,0.95));
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          z-index: 2000;
          color: white;
          font-family: 'Arial', sans-serif;
        }

        .podium-title {
          font-size: 42px;
          margin-bottom: 40px;
          text-transform: uppercase;
          text-shadow: 0 0 10px rgba(255,215,0,0.7);
          animation: glow 2s infinite alternate;
        }

        @keyframes glow {
          from {
            text-shadow: 0 0 10px rgba(255,215,0,0.7);
          }
          to {
            text-shadow: 0 0 20px rgba(255,215,0,1), 0 0 30px gold;
          }
        }

        .podium-container {
          display: flex;
          justify-content: center;
          align-items: flex-end;
          width: 80%;
          max-width: 800px;
          height: 350px;
          margin-bottom: 50px;
        }

        .podium-step {
          display: flex;
          flex-direction: column;
          align-items: center;
          border-radius: 10px 10px 0 0;
          transition: all 0.5s ease-in-out;
          box-shadow: 0 0 20px rgba(0,0,0,0.5);
          overflow: hidden;
        }

        .podium-position {
          font-size: 36px;
          margin: 10px 0;
        }

        .podium-username {
          font-size: 22px;
          font-weight: bold;
          margin: 5px 0;
          text-align: center;
          padding: 0 10px;
        }

        .podium-score {
          font-size: 18px;
          margin: 5px 0 10px 0;
        }

        .podium-avatar {
          width: 80px;
          height: 80px;
          border-radius: 50%;
          background-color: #333;
          margin: 10px 0;
          display: flex;
          justify-content: center;
          align-items: center;
          font-size: 32px;
        }

        .restart-counter {
          font-size: 24px;
          margin-top: 30px;
          animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
          from {
            transform: scale(1);
          }
          to {
            transform: scale(1.05);
          }
        }

        .game-clock {
          position: absolute;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          background-color: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 8px 15px;
          border-radius: 20px;
          font-family: 'Arial', sans-serif;
          font-size: 16px;
          z-index: 1000;
          box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .game-info {
          display: flex;
          align-items: center;
        }

        .time-warning {
          color: #ff5555;
          animation: blink 1s infinite;
        }

        @keyframes blink {
          50% {
            opacity: 0.5;
          }
        }
    </style>
</head>
<body>
	<div id="login-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 1000;">
		<div style="background-color: #333; padding: 20px; border-radius: 10px; text-align: center; max-width: 500px;">
			<h2 style="color: white; margin-bottom: 20px;">Robot Warfare</h2>
			<p style="color: white; margin-bottom: 20px;">Enter a username to join the battle!</p>
			<input type="text" id="username-input" placeholder="Your name" style="padding: 8px; width: 80%; margin-bottom: 15px; border-radius: 5px; border: none;">
			<button id="join-button" style="background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer;">Join</button>
			<div style="margin-top: 20px; text-align: left; color: #ccc; font-size: 14px; max-width: 450px;">
				<h3 style="color: white; margin-bottom: 10px; text-align: center;">Game Instructions</h3>
				<p style="margin-bottom: 10px;">In <span style="color: #4CAF50; font-weight: bold;">Robot Warfare</span>, control your robot and compete against other players in a battle for dominance!</p>
				<div style="margin-top: 10px; margin-bottom: 5px;"><span style="color: white; font-weight: bold;">Objective:</span></div>
				<ul style="list-style-type: none; padding-left: 10px; margin-top: 5px;">
					<li>‚Ä¢ Collect processors to upgrade your robot</li>
					<li>‚Ä¢ Find cannons to add firepower to your arsenal</li>
					<li>‚Ä¢ Defeat other players and claim their resources</li>
					<li>‚Ä¢ Become the most powerful robot on the battlefield!</li>
				</ul>
				<div style="margin-bottom: 5px;"><span style="color: white; font-weight: bold;">Controls:</span></div>
				<ul style="list-style-type: none; padding-left: 10px; margin-top: 5px;">
					<li>‚Üë / ‚Üì : Move forward/backward</li>
					<li>‚Üê / ‚Üí : Rotate robot</li>
					<li>Left Ctrl : Fire weapon</li>
					<li>C : Change camera view</li>
					<li>Right mouse button : Rotate camera</li>
					<li>Mouse wheel : Zoom in/out</li>
				</ul>
			</div>
		</div>
	</div>
    <div id="info">
        <div class="stat">
            <span>HP:</span>
            <span id="hp" class="stat-value">100</span><span class="stat-value">/</span><span id="maxhp" class="stat-value">100</span>
        </div>
        <div class="stat">
            <span>Defense:</span>
            <span id="def" class="stat-value">10</span>
        </div>
        <div class="stat">
            <span>Attack:</span>
            <span id="atk" class="stat-value">10</span>
        </div>
        <div class="stat">
            <span>Attack Speed:</span>
            <span id="atkspeed" class="stat-value">0.5</span>
        </div>
        <div class="stat">
            <span>Range:</span>
            <span id="range" class="stat-value">10</span>
        </div>
        <div class="stat">
            <span>Speed:</span>
            <span id="speed" class="stat-value">0.02</span>
        </div>
        <div class="stat">
            <span>Repair Speed:</span>
            <span id="repair" class="stat-value">0.1</span>
        </div>
		<div class="stat">
			<span>Processors:</span>
			<span id="processors" class="stat-value">0</span>
		</div>
        <div class="controls">
            ‚Üê ‚Üí : rotate | ‚Üë ‚Üì : move forward/backward | Left Ctrl: attack
        </div>
    </div>
	<div id="scoreboard" style="position: absolute; top: 10px; right: 10px; color: white; font-family: Arial, sans-serif; background-color: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto; width: 250px;">
		<h3 style="margin: 0 0 10px 0; text-align: center;">Players</h3>
		<div id="players-list"></div>
	</div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.module.js';

		import { io } from 'https://cdn.socket.io/4.4.1/socket.io.esm.min.js';
		
		let listenersInitialized = false;		

		function disposeThreeObject(obj) {
			if (!obj) return;
			
			// Arr√™ter les animations √©ventuelles
			if (obj.userData && obj.userData.animationId) {
				cancelAnimationFrame(obj.userData.animationId);
			}
			
			// Parcourir les enfants r√©cursivement
			while (obj.children && obj.children.length > 0) {
				disposeThreeObject(obj.children[0]);
				obj.remove(obj.children[0]);
			}
			
			// Disposer de la g√©om√©trie
			if (obj.geometry) {
				obj.geometry.dispose();
			}
			
			// Disposer des mat√©riaux
			if (obj.material) {
				if (Array.isArray(obj.material)) {
					obj.material.forEach(mat => {
						if (mat.map) mat.map.dispose();
						if (mat.emissiveMap) mat.emissiveMap.dispose();
						if (mat.normalMap) mat.normalMap.dispose();
						if (mat.specularMap) mat.specularMap.dispose();
						mat.dispose();
					});
				} else {
					if (obj.material.map) obj.material.map.dispose();
					if (obj.material.emissiveMap) obj.material.emissiveMap.dispose();
					if (obj.material.normalMap) obj.material.normalMap.dispose();
					if (obj.material.specularMap) obj.material.specularMap.dispose();
					obj.material.dispose();
				}
			}
			
			// Nettoyer les √©ventuelles textures
			if (obj.texture) {
				obj.texture.dispose();
			}
		}
		
		// Nom d'utilisateur par d√©faut
		let username = `Robot-${Math.floor(Math.random() * 1000)}`;
		
		let animationId = null;
		
		// √âtablir la connexion WebSocket
		const socket = io('https://snowball-test.onrender.com/',{
			reconnectionAttempts: 5,       // Augmenter le nombre de tentatives de reconnexion
			reconnectionDelay: 1000,       // Commencer avec un d√©lai court (1 seconde)
			reconnectionDelayMax: 5000,    // Maximum 5 secondes entre les tentatives
			timeout: 10000,                // Timeout de connexion de 10 secondes
			forceNew: true,                // Forcer une nouvelle connexion
			transports: ['websocket', 'polling']  // Essayer WebSocket d'abord, puis polling
		});
		
		// Configurer les √©couteurs d'√©v√©nements imm√©diatement
		setupSocketListeners();
		
		// Gestion des erreurs de connexion
		socket.on('connect_error', (err) => {
			console.error('Erreur de connexion au serveur:', err);
			showConnectionError();
		});

		// Afficher une notification d'erreur de connexion
		function showConnectionError() {
			const errorDiv = document.createElement('div');
			errorDiv.style.position = 'absolute';
			errorDiv.style.top = '10px';
			errorDiv.style.left = '50%';
			errorDiv.style.transform = 'translateX(-50%)';
			errorDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
			errorDiv.style.color = 'white';
			errorDiv.style.padding = '10px';
			errorDiv.style.borderRadius = '5px';
			errorDiv.style.zIndex = '1000';
			errorDiv.textContent = 'Erreur de connexion au serveur. Veuillez rafra√Æchir la page.';
			document.body.appendChild(errorDiv);
		}
		
		// Classe pour le contr√¥leur de cam√©ra
		class CameraController {
			constructor(player) {
				// R√©f√©rence au joueur
				this.player = player;
				
				// Mode de cam√©ra actuel (troisi√®me personne par d√©faut)
				this.mode = 'thirdPerson';
				
				// Param√®tres de la cam√©ra
				this.distance = 30;      // Distance entre la cam√©ra et le joueur
				this.minDistance = 5;    // Distance minimale (pour zoom)
				this.maxDistance = 100;  // Distance maximale (pour zoom)
				this.height = 10;        // Hauteur relative de la cam√©ra
				
				// Angles de rotation (en radians)
				this.rotationHorizontal = Math.PI;  // Rotation horizontale autour du joueur (commence derri√®re)
				this.rotationVertical = Math.PI / 6;  // Rotation verticale (inclinaison)
				this.minVerticalRotation = -0.2;  // Limite pour ne pas passer sous le sol
				this.maxVerticalRotation = Math.PI / 2 - 0.1;  // Limite pour ne pas passer au-dessus
				
				// √âtat de la souris
				this.isMouseDown = false;
				this.mouseX = 0;
				this.mouseY = 0;
				
				// Sensibilit√© des contr√¥les
				this.rotationSpeed = 0.005;  // Vitesse de rotation avec la souris
				this.zoomSpeed = 1;        // Vitesse de zoom avec la molette (augment√©e)
				
				// Retour automatique √† la position troisi√®me personne
				this.returnToThirdPerson = true;    // Si la cam√©ra doit revenir derri√®re le joueur
				this.returnSpeed = 0.05;           // Vitesse de retour
				
				// Mettre en place les √©couteurs d'√©v√©nements
				this.setupEventListeners();
				
				// Ajouter les informations d'aide √† l'interface
				this.addCameraControlsHelp();
			}
			
			// Configurer les √©couteurs d'√©v√©nements pour la souris
			setupEventListeners() {
				// Mouvement de la souris
				document.addEventListener('mousemove', (event) => {
					if (this.isMouseDown) {
						const deltaX = event.clientX - this.mouseX;
						const deltaY = event.clientY - this.mouseY;
						
						this.rotationHorizontal -= deltaX * this.rotationSpeed*1.1;
						this.rotationVertical += deltaY * this.rotationSpeed;
						
						// Limiter la rotation verticale pour √©viter les probl√®mes
						this.rotationVertical = Math.max(this.minVerticalRotation, Math.min(this.maxVerticalRotation, this.rotationVertical));
					}
					
					this.mouseX = event.clientX;
					this.mouseY = event.clientY;
				});
				
				// Clic de souris
				document.addEventListener('mousedown', (event) => {
					// Clic droit uniquement pour la rotation de cam√©ra
					if (event.button === 2) {
						this.isMouseDown = true;
						event.preventDefault();
					}
				});
				
				// Rel√¢chement du clic
				document.addEventListener('mouseup', (event) => {
					if (event.button === 2) {
						this.isMouseDown = false;
					}
				});
				
				// Zoom avec la molette
				document.addEventListener('wheel', (event) => {
					const zoomAmount = event.deltaY * this.zoomSpeed / 100;
					this.distance += zoomAmount;
					this.distance = Math.max(this.minDistance, Math.min(this.maxDistance, this.distance));
					
					event.preventDefault();
				}, { passive: false });
				
				// Emp√™cher le menu contextuel du clic droit
				document.addEventListener('contextmenu', (event) => {
					event.preventDefault();
				});
				
				// Touches pour changer de mode
				document.addEventListener('keydown', (event) => {
					if (event.key === 'c' || event.key === 'C') {
						this.toggleCameraMode();
					}
				});
			}
			
			// Passer au mode suivant
			toggleCameraMode() {
				const modes = ['thirdPerson', 'firstPerson', 'topDown'];
				const currentIndex = modes.indexOf(this.mode);
				const nextIndex = (currentIndex + 1) % modes.length;
				this.mode = modes[nextIndex];
				
				console.log(`Mode cam√©ra: ${this.getCameraModeDescription()}`);
				this.updateCameraHelpDisplay();
				
				return this.mode;
			}
			
			// Obtenir une description du mode
			getCameraModeDescription() {
				switch (this.mode) {
					case 'thirdPerson': return "Third-person view";
					case 'firstPerson': return "First-person view";
					case 'topDown': return "Top-down view";
					default: return "Mode inconnu";
				}
			}
			
			// Mettre √† jour la position de la cam√©ra
			updateCamera(camera) {
				if (!player || !player.mesh || !player.isAlive) return;
				
				switch(this.mode) {
					case 'thirdPerson':
						this.updateThirdPersonCamera(camera);
						break;
					case 'firstPerson':
						this.updateFirstPersonCamera(camera);
						break;
					case 'topDown':
						this.updateTopDownCamera(camera);
						break;
				}
			}
			
			// Mode troisi√®me personne - cam√©ra suivant le joueur
			updateThirdPersonCamera(camera) {
				// Si le bouton droit n'est pas enfonc√© et qu'on est en mode retour automatique
				if (!this.isMouseDown && this.returnToThirdPerson && this.mode === 'thirdPerson') {
					// Calculer l'angle cible en utilisant la direction du joueur
					// La direction est stock√©e dans le joueur
					const playerDirection = this.player.direction.clone();
					
					// Calculer l'angle √† partir du vecteur de direction (face √† l'oppos√©)
					const targetAngle = Math.atan2(-playerDirection.x, -playerDirection.z);
					
					// Normaliser la diff√©rence d'angle
					let angleDiff = targetAngle - this.rotationHorizontal;
					if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
					if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
					
					// Appliquer un retour progressif
					if (Math.abs(angleDiff) > 0.05) {
						this.rotationHorizontal += angleDiff * this.returnSpeed;
					}
				}
				
				// Calculer la position de la cam√©ra en coordonn√©es sph√©riques 
				const x = this.player.mesh.position.x + Math.sin(this.rotationHorizontal) * Math.cos(this.rotationVertical) * this.distance;
				const z = this.player.mesh.position.z + Math.cos(this.rotationHorizontal) * Math.cos(this.rotationVertical) * this.distance;
				const y = this.player.mesh.position.y + Math.sin(this.rotationVertical) * this.distance + this.height;
				
				// Mettre √† jour la position de la cam√©ra
				camera.position.set(x, y, z);
				
				// Restaurer le FOV normal
				camera.fov = 15;
				camera.updateProjectionMatrix();
				
				// Faire regarder la cam√©ra vers le joueur
				camera.lookAt(
					this.player.mesh.position.x,
					this.player.mesh.position.y + 1, // Viser un peu au-dessus du centre du robot
					this.player.mesh.position.z
				);
			}
			
			// Mode premi√®re personne
			updateFirstPersonCamera(camera) {
				// V√©rifier que le joueur est en vie
				if (!this.player.isAlive) return;

				try {
					// Position du groupe du canon (qui contient le viseur)
					const cannonPosition = new THREE.Vector3();
					
					// Obtenir la position mondiale du groupe du canon
					this.player.cannonGroup.updateWorldMatrix(true, false);
					cannonPosition.setFromMatrixPosition(this.player.cannonGroup.matrixWorld);
					
					// Ajouter un petit d√©calage vers le haut pour simuler la position du viseur
					cannonPosition.y += 0.2;
					
					// Positionner la cam√©ra l√† o√π serait le viseur
					camera.position.copy(cannonPosition);
					
					// Obtenir la direction du canon
					const direction = new THREE.Vector3(0, 0, -1);
					direction.applyQuaternion(this.player.cannonGroup.getWorldQuaternion(new THREE.Quaternion()));
					
					// Assurer que la direction reste horizontale
					direction.y = 0;
					direction.normalize();
					
					// Calculer le point vers lequel la cam√©ra regarde
					const lookTarget = new THREE.Vector3();
					lookTarget.copy(cannonPosition).add(direction.multiplyScalar(10));
					
					// Modifier le FOV pour une vue grand angle en premi√®re personne
					camera.fov = 80;
					camera.updateProjectionMatrix();
					
					camera.lookAt(lookTarget);
				} catch (error) {
					console.error("Erreur dans updateFirstPersonCamera:", error);
				}
			}
			
			// Mode vue de dessus
			updateTopDownCamera(camera) {
				const height = this.distance;
				
				// Position de la cam√©ra au-dessus du joueur
				camera.position.set(
					this.player.mesh.position.x,
					this.player.mesh.position.y + height,
					this.player.mesh.position.z
				);
				
				// Orientation vers le joueur avec une rotation autour de l'axe vertical
				const target = new THREE.Vector3(
					this.player.mesh.position.x + Math.sin(this.rotationHorizontal) * 0.5,
					this.player.mesh.position.y,
					this.player.mesh.position.z + Math.cos(this.rotationHorizontal) * 0.5
				);
				
				// Restaurer le FOV normal
				camera.fov = 15;
				camera.updateProjectionMatrix();
				
				camera.lookAt(target);
			}
			
			// Ajouter les informations d'aide pour les contr√¥les de cam√©ra
			addCameraControlsHelp() {
				// Cr√©er l'√©l√©ment d'aide
				const cameraHelp = document.createElement('div');
				cameraHelp.id = 'camera-help';
				cameraHelp.style.cssText = `
					position: absolute;
					top: 10px;
					left: 10px;
					color: white;
					font-family: Arial, sans-serif;
					background-color: rgba(0, 0, 0, 0.7);
					padding: 10px;
					border-radius: 5px;
					width: 250px;
					font-size: 14px;
				`;
				
				// Ajouter l'√©l√©ment √† la page
				document.body.appendChild(cameraHelp);
				
				// Mettre √† jour l'affichage initial
				this.updateCameraHelpDisplay();
			}
			
			// Mettre √† jour l'affichage de l'aide
			updateCameraHelpDisplay() {
				const cameraHelp = document.getElementById('camera-help');
				if (!cameraHelp) return;
				
				let helpContent = `<strong>Camera Controls</strong><br>`;
				helpContent += `Current Mode: <strong>${this.getCameraModeDescription()}</strong><br><br>`;
				helpContent += `<strong>Souris:</strong><br>`;
				helpContent += `Right click: Camera rotation<br>`;
				helpContent += `Scroll: Zoom in/out<br><br>`;
				helpContent += `<strong>Clavier:</strong><br>`;
				helpContent += `<strong>C</strong>: Change camera mode<br>`;
				
				cameraHelp.innerHTML = helpContent;
			}
		}		
		
		// Classe pour les processeurs
        class Processor {
            constructor(scene, position, type, collisionSystem) {
                // Type de processeur (hp, resistance, attack, attackSpeed, range, speed, repairSpeed)
                this.type = type;
                
                // Propri√©t√©s visuelles selon le type
                const typeProperties = {
                    hp: { color: 0x00ff00, boost: 1 },             // Vert
                    resistance: { color: 0xffa500, boost: 1 },     // Orange
                    attack: { color: 0xff0000, boost: 1 },         // Rouge
                    attackSpeed: { color: 0xffff00, boost: 0.02 }, // Jaune
                    range: { color: 0x0000ff, boost: 1 },          // Bleu
                    speed: { color: 0x4b0082, boost: 0.002 },      // Indigo
                    repairSpeed: { color: 0x8a2be2, boost: 0.05 }  // Violet
                };
                
                this.boost = typeProperties[type].boost;
                const color = typeProperties[type].color;
                
                // Cr√©ation du groupe pour contenir le processeur
                this.mesh = new THREE.Group();
                this.mesh.position.copy(position);
                
                // Mat√©riau de base pour le processeur
                const baseMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.3,
                    metalness: 0.8,
                    emissive: color,
                    emissiveIntensity: 0.3
                });
                
                // Base du processeur (carr√© plat)
                const baseGeometry = new THREE.BoxGeometry(0.2, 0.02, 0.2);
                this.base = new THREE.Mesh(baseGeometry, baseMaterial);
                this.mesh.add(this.base);
                
                // Cr√©er quelques "composants" simples pour ressembler √† un processeur
                // Puce centrale
                const chipGeometry = new THREE.BoxGeometry(0.1, 0.03, 0.1);
                const chip = new THREE.Mesh(chipGeometry, baseMaterial);
                chip.position.y = 0.05;
                this.mesh.add(chip);
                
                // Quelques d√©tails pour ressembler √† un processeur
                const detailGeometry = new THREE.BoxGeometry(0.02, 0.01, 0.02);
                for (let i = 0; i < 4; i++) {
                    const detail = new THREE.Mesh(detailGeometry, baseMaterial);
                    // Placer les d√©tails aux coins de la puce
                    detail.position.set(
                        (i % 2 ? 0.04 : -0.04),
                        0.04,
                        (i < 2 ? 0.04 : -0.04)
                    );
                    this.mesh.add(detail);
                }
                
                // Animation de flottement
                this.floatHeight = position.y;
                this.floatSpeed = 0.5;
                this.floatOffset = Math.random() * Math.PI * 2;
                
                // Ajouter √† la sc√®ne
                scene.add(this.mesh);
                
                // Gestion des collisions
                this.collider = this.base;
                this.hasCollision = true;
                this.scene = scene;
                this.collisionSystem = collisionSystem;
                this.collisionSystem.addObject(this);
                
            }
            
            // Mise √† jour du processeur
            update() {

				// Animation de flottement standard
				this.updateFloat();
                
                // Rotation douce
                this.mesh.rotation.y += 0.01;
            }
            
            // Animation de flottement
            updateFloat() {
                const time = performance.now() * 0.001;
                // Amplitude de flottement augment√©e pour plus de mouvement
                this.mesh.position.y = this.floatHeight + Math.sin(time * this.floatSpeed + this.floatOffset) * 0.15;
            }
            
            // D√©truire le processeur
            destroy() {
                this.scene.remove(this.mesh);
                this.collisionSystem.removeObject(this);
            }
        }

        // Classe pour les canons ramassables
        class Cannon {
            constructor(scene, position, collisionSystem) {
                // Groupe pour contenir le canon
                this.mesh = new THREE.Group();
                this.mesh.position.copy(position);
                
                // Mat√©riau pour le canon
                const cannonMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    roughness: 0.5,
                    metalness: 0.8,
                    emissive: 0x222222,
                    emissiveIntensity: 0.2
                });
                
                // Base du canon
                const baseGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.08, 8);
                this.base = new THREE.Mesh(baseGeometry, cannonMaterial);
                this.mesh.add(this.base);
                
                // Canon
                const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.15, 8);
                barrelGeometry.rotateX(Math.PI / 2);
                this.barrel = new THREE.Mesh(barrelGeometry, cannonMaterial);
                this.barrel.position.y = 0.06;
                this.barrel.position.z = -0.08;
                this.mesh.add(this.barrel);
                
                // D√©tails visuels
                const detailMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    roughness: 0.4,
                    metalness: 0.9
                });
                
                // Anneau autour du canon
                const ringGeometry = new THREE.TorusGeometry(0.04, 0.01, 8, 16);
                ringGeometry.rotateX(Math.PI / 2);
                this.ring = new THREE.Mesh(ringGeometry, detailMaterial);
                this.ring.position.y = 0.06;
                this.ring.position.z = -0.03;
                this.mesh.add(this.ring);
                
                // Animation de flottement
                this.floatHeight = position.y;
                this.floatSpeed = 0.7;
                this.floatOffset = Math.random() * Math.PI * 2;
                
                // Ajouter √† la sc√®ne
                scene.add(this.mesh);
                
                // Gestion des collisions
                this.collider = this.base;
                this.hasCollision = true;
                this.scene = scene;
                this.collisionSystem = collisionSystem;
                this.collisionSystem.addObject(this);
                
                // Propri√©t√© pour identifier le type d'objet
                this.type = 'cannon';
                
                // √âtat d'animation pour le rebond
                this.isBouncing = false;
                this.bounceVelocity = { x: 0, y: 0, z: 0 };
                this.gravity = 0.005;
                this.friction = 0.98;
            }
            
            // Mise √† jour du canon
            update() {
                if (this.isBouncing) {
                    // Animation de rebond physique
                    this.updateBounce();
                } else {
                    // Animation de flottement standard
                    this.updateFloat();
                }
                
                // Rotation douce
                this.mesh.rotation.y += 0.015;
            }
            
            // Animation de flottement
            updateFloat() {
                const time = performance.now() * 0.001;
                this.mesh.position.y = this.floatHeight + Math.sin(time * this.floatSpeed + this.floatOffset) * 0.15;
            }
            
            // Animation de rebond
            updateBounce() {
                // Appliquer la gravit√© √† la v√©locit√© verticale
                this.bounceVelocity.y -= this.gravity;
                
                // Mettre √† jour la position
                this.mesh.position.x += this.bounceVelocity.x;
                this.mesh.position.y += this.bounceVelocity.y;
                this.mesh.position.z += this.bounceVelocity.z;
                
                // Appliquer la friction aux composantes horizontales
                this.bounceVelocity.x *= this.friction;
                this.bounceVelocity.z *= this.friction;
                
                // Rebond au sol
                if (this.mesh.position.y < 0.5) {
                    this.mesh.position.y = 0.5;
                    
                    // Rebond avec perte d'√©nergie
                    if (Math.abs(this.bounceVelocity.y) > 0.01) {
                        this.bounceVelocity.y = -this.bounceVelocity.y * 0.6;
                    } else {
                        // Arr√™ter le rebond si l'√©nergie est trop basse
                        this.bounceVelocity.y = 0;
                        this.isBouncing = false;
                        this.floatHeight = 0.5;
                    }
                }
                
                // V√©rifier les limites de la carte
                const mapHalfWidth = 50;
                const mapHalfHeight = 50;
                
                // Bornes X
                if (Math.abs(this.mesh.position.x) > mapHalfWidth - 1) {
                    if (this.mesh.position.x > 0) {
                        this.mesh.position.x = mapHalfWidth - 1;
                    } else {
                        this.mesh.position.x = -(mapHalfWidth - 1);
                    }
                    this.bounceVelocity.x = -this.bounceVelocity.x * 0.8;
                }
                
                // Bornes Z
                if (Math.abs(this.mesh.position.z) > mapHalfHeight - 1) {
                    if (this.mesh.position.z > 0) {
                        this.mesh.position.z = mapHalfHeight - 1;
                    } else {
                        this.mesh.position.z = -(mapHalfHeight - 1);
                    }
                    this.bounceVelocity.z = -this.bounceVelocity.z * 0.8;
                }
            }
            
            
            // D√©truire le canon
            destroy() {
                this.scene.remove(this.mesh);
                this.collisionSystem.removeObject(this);
            }
        }

        // Classe pour la gestion des collisions
        class CollisionSystem {
            constructor() {
                this.collidableObjects = [];
            }

            // Ajouter un objet au syst√®me de collision
            addObject(object) {
                if (object.collider && object.hasCollision) {
                    this.collidableObjects.push(object);
                }
            }

            // Retirer un objet du syst√®me de collision
            removeObject(object) {
                const index = this.collidableObjects.indexOf(object);
                if (index !== -1) {
                    this.collidableObjects.splice(index, 1);
                }
            }

            // V√©rifier s'il y a collision entre deux objets
            checkCollision(obj1, obj2) {
                // V√©rification simple bas√©e sur les bo√Ætes englobantes
                const box1 = new THREE.Box3().setFromObject(obj1.collider);
                const box2 = new THREE.Box3().setFromObject(obj2.collider);
                
                return box1.intersectsBox(box2);
            }

            // V√©rifier les collisions pour un objet sp√©cifique
            checkCollisionForObject(obj) {
                let collisions = [];
                
                for (const other of this.collidableObjects) {
                    // Ne pas v√©rifier la collision avec soi-m√™me
                    if (other === obj) continue;
                    
                    if (this.checkCollision(obj, other)) {
                        collisions.push(other);
                    }
                }
                
                return collisions;
            }
			checkRayCollision(origin, direction, maxDistance, excludeObject) {
				const intersects = [];
				
				for (const obj of this.collidableObjects) {
					if (obj === excludeObject) continue;
					if (!obj.hasCollision || !obj.collider) continue;
					
					const raycaster = new THREE.Raycaster(origin, direction, 0, maxDistance);
					const objIntersects = raycaster.intersectObject(obj.collider, true);
					
					if (objIntersects.length > 0) {
						objIntersects.forEach(intersect => {
							intersects.push({
								distance: intersect.distance,
								point: intersect.point,
								normal: intersect.face.normal,
								object: obj
							});
						});
					}
				}
				
				// Trier par distance
				intersects.sort((a, b) => a.distance - b.distance);
				return intersects;
			}
        }

        // Classe pour les projectiles
        class Projectile {
            constructor(scene, position, direction, owner, collisionSystem) {
                // Groupe pour contenir le projectile et sa tra√Æn√©e
                this.group = new THREE.Group();
                this.group.position.copy(position);
                scene.add(this.group);
                
                // Propri√©t√©s de mouvement
                this.direction = direction.normalize();
                this.speed = 0.01; // vitesse du projectile
                this.distance = 0;
                this.maxDistance = owner.range;
                
                // Propri√©t√©s de combat
                this.damage = owner.attack;
                this.owner = owner;
                
                // Cr√©er un obus en forme de capsule (plus r√©aliste qu'une sph√®re)
                const capsuleLength = 0.02;
                const capsuleRadius = 0.02;
                const capsuleGeometry = new THREE.CapsuleGeometry(capsuleRadius, capsuleLength, 8, 8);
                const capsuleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffcc00,  // Couleur dor√©e pour un obus
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0xff4400,
                    emissiveIntensity: 0.2
                });
                this.mesh = new THREE.Mesh(capsuleGeometry, capsuleMaterial);
                
                // Orienter l'obus dans la direction du tir
                this.mesh.rotation.x = Math.PI / 2;
                this.mesh.position.z = 0;
                this.group.add(this.mesh);
                
                // Propri√©t√©s de collision
                this.collider = this.mesh;
                this.hasCollision = true;
                this.collisionSystem = collisionSystem;
                this.collisionSystem.addObject(this);
                
                // R√©f√©rence √† la sc√®ne pour pouvoir supprimer le projectile
                this.scene = scene;
                
                // Ajouter une petite lumi√®re au projectile
                this.light = new THREE.PointLight(0xff7700, 0.8, 1);
                this.light.position.copy(position);
                scene.add(this.light);
            }
            
            
		// Dans la classe Projectile du fichier index.html
		// Modifiez la m√©thode update() pour ajouter des logs d√©taill√©s:

		update() {
		  // Vecteur de d√©placement
		  const movement = this.direction.clone().multiplyScalar(this.speed);
		  
		  // D√©placer le projectile
		  this.group.position.add(movement);
		  this.light.position.copy(this.group.position);
		  
		  // Faire tourner l√©g√®rement l'obus pour un effet r√©aliste
		  this.mesh.rotation.z += 0.1;
		  
		  // Mettre √† jour la distance parcourue (distance r√©elle)
		  this.distance += movement.length();
		  
		  // V√©rifier si le projectile a atteint sa port√©e maximale
		  if (this.distance >= this.maxDistance) {
			this.explode();
			return false;
		  }
		  
		  // V√©rifier les collisions
		  const collisions = this.collisionSystem.checkCollisionForObject(this);
		  
		  // Si projectile d'un bot, ajouter des logs d√©taill√©s
		  const isBotProjectile = this.owner.playerId && this.owner.playerId.startsWith('bot-');
		  if (isBotProjectile && collisions.length > 0) {
			console.group(`üîç Collision d√©tect√©e pour projectile de ${this.owner.username || this.owner.playerId}`);
			console.log(`Position projectile:`, this.group.position);
			console.log(`Distance parcourue: ${this.distance.toFixed(2)} / ${this.maxDistance.toFixed(2)}`);
			console.log(`Nombre d'objets en collision: ${collisions.length}`);
		  }
		  
		  for (const obj of collisions) {
			// Ignorer le propri√©taire du projectile
			if (obj === this.owner) {
			  if (isBotProjectile) {
				console.log(`‚ö†Ô∏è Collision avec son propre propri√©taire (${this.owner.username || this.owner.playerId}), ignor√©e`);
			  }
			  continue;
			}
			
			// Log d√©taill√© pour les projectiles de bots
			if (isBotProjectile) {
			  console.log(`Collision avec:`, {
				type: obj.constructor?.name || 'Type inconnu',
				isPlayer: obj instanceof Player,
				id: obj.playerId || obj.id || 'ID inconnu',
				name: obj.username || 'Nom inconnu',
				position: obj.mesh?.position || obj.position || 'Position inconnue',
				userDataType: obj.userData?.type || 'Pas de userData.type'
			  });
			  
			  // Distance entre le projectile et l'objet
			  if (obj.mesh && obj.mesh.position) {
				const distance = this.group.position.distanceTo(obj.mesh.position);
				console.log(`Distance entre projectile et objet: ${distance.toFixed(2)} unit√©s`);
			  }
			  
			  // V√©rification de la hi√©rarchie d'objets
			  if (obj.mesh && obj.mesh.parent) {
				console.log(`Hi√©rarchie de l'objet: parent=${obj.mesh.parent.type || 'type inconnu'}`);
			  }
			}
			
			// V√©rifier si c'est un objet avec lequel on peut collisionner
			if (obj.userData && (obj.userData.type === 'wall' || obj.userData.type === 'floor' || 
								 obj.userData.type === 'structure' || obj.userData.type === 'tree')) {
				// Si l'objet est destructible (poss√®de takeDamage), infliger des d√©g√¢ts
				if (obj.takeDamage) {
					// IMPORTANT: Envoyer au serveur si c'est le joueur principal
					if (player && player.isMainPlayer) {
						socket.emit('structureDamaged', {
							structureId: obj.id || '',
							damage: this.damage,
							position: {
								x: obj.mesh.position.x,
								y: obj.mesh.position.y,
								z: obj.mesh.position.z
							}
						});
					}
					obj.takeDamage(this.damage);
				}
				if (isBotProjectile) console.log(`üí• Explosion sur structure/terrain`);
				if (isBotProjectile) console.groupEnd();
				this.explode();
				return false;
			}
			
			// Si c'est un autre joueur, infliger des d√©g√¢ts et cr√©er une explosion
			else if (obj.takeDamage && obj !== this.owner) {
				// D√©terminer l'ID du joueur touch√© (diff√©rent selon si c'est un joueur ou un autre objet)
				let targetId = '';
				
				// V√©rifier si l'objet touch√© est un joueur
				if (obj instanceof Player) {
					targetId = obj.playerId;
					if (isBotProjectile) console.log(`üéØ Joueur touch√©: ${obj.username}, ID: ${targetId}`);
					
					// Appliquer directement l'effet visuel localement pour feedback imm√©diat
					obj.showDamageEffect();
				}
				
				// IMPORTANT: Envoyer l'impact au serveur uniquement si c'est le joueur principal
				if (player && player.isMainPlayer) {
					// CORRECTION: √âviter d'utiliser l'ID temporaire qui cause la d√©synchronisation
					socket.emit('projectileHit', {
						// Informations sur le projectile pour identification c√¥t√© serveur
						ownerId: player.playerId,  // Ajouter l'ID du tireur
						originPosition: {          // Position de d√©part du projectile
							x: this.owner.mesh.position.x,
							y: this.owner.mesh.position.y,
							z: this.owner.mesh.position.z
						},
						// Informations sur l'impact
						targetId: targetId,
						targetType: 'player',
						damage: this.damage,
						position: {                // Position actuelle lors de l'impact
							x: this.group.position.x,
							y: this.group.position.y,
							z: this.group.position.z
						}
					});
					if (isBotProjectile) console.log(`üì§ Impact envoy√© au serveur: joueur ${targetId}, d√©g√¢ts ${this.damage}`);
				}
				
				if (isBotProjectile) console.groupEnd();
				this.explode();
				return false;
			} else {
				// Pour les autres objets qui ont takeDamage mais ne sont pas des joueurs
				if (player && player.isMainPlayer) {
					socket.emit('projectileHit', {
						ownerId: player.playerId,
						targetId: obj.id || '',
						targetType: 'structure',
						damage: this.damage,
						position: {
							x: this.group.position.x,
							y: this.group.position.y,
							z: this.group.position.z
						}
					});
					if (isBotProjectile) console.log(`üì§ Impact envoy√© au serveur: structure ${obj.id || 'inconnu'}`);
				}
				
				if (isBotProjectile) {
					console.log(`üí• Explosion sur objet non classifi√©`);
					console.groupEnd();
				}
				this.explode();
				return false;
			}
		  }
		  
		  if (isBotProjectile && collisions.length > 0) {
			console.log(`‚úÖ Aucune collision valide, projectile continue`);
			console.groupEnd();
		  }
		  
		  return true;
		}		
            // Cr√©er une explosion et d√©truire le projectile
            explode() {
                // Cr√©er un effet d'explosion
                this.createExplosionEffect();
                
                // Supprimer le projectile apr√®s un court d√©lai pour voir l'explosion
                setTimeout(() => {
                    this.destroy();
                }, 100);
            }
            
            // Cr√©er un effet d'explosion
            createExplosionEffect() {
                // Mat√©riau pour l'explosion
                const explosionMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff6600,
                    emissive: 0xff9900,
                    emissiveIntensity: 1,
                    transparent: true,
                    opacity: 0.9
                });
                
                // Cr√©er une sph√®re pour l'explosion
                const explosionGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(this.group.position);
                this.scene.add(explosion);
                
                // Faire grandir puis dispara√Ætre l'explosion
                let scale = 0.1;
                const expandExplosion = () => {
                    scale += 0.15;
                    explosion.scale.set(scale, scale, scale);
                    explosionMaterial.opacity -= 0.05;
                    
                    if (scale < 2) {
                        requestAnimationFrame(expandExplosion);
                    } else {
                        this.scene.remove(explosion);
						this.animationId = null; //suivre l'ID d'animation
                    }
                };
                
				this.animationId = requestAnimationFrame(expandExplosion);
                
                // Augmenter temporairement la luminosit√© du projectile
                this.light.intensity = 3;
                this.light.distance = 6;
            }
            
            // D√©truire le projectile
            destroy() {
				// Annuler toutes les animations en cours
				if (this.animationId) {
					cancelAnimationFrame(this.animationId);
					this.animationId = null;
				}{
                this.scene.remove(this.group);
                this.scene.remove(this.light);
                this.collisionSystem.removeObject(this);
				}
			}		
	    }

		// Classe pour le r√©servoir d'eau sur tour en b√©ton
		class WaterTower {
			constructor(scene, position, collisionSystem) {
				// Groupe principal pour contenir toute la structure
				this.mesh = new THREE.Group();
				this.mesh.position.copy(position);
				scene.add(this.mesh);
				
				// R√©f√©rences pour la gestion des collisions
				this.scene = scene;
				this.collisionSystem = collisionSystem;
				
				// Dimensions de la tour
				this.towerTopRadius = 1.5;
				this.towerBottomRadius = 2;
				this.towerHeight = 12;
				this.towerY = this.towerHeight / 2; // Position Y du centre de la tour
				
				// Dimensions de la base
				this.baseRadius = 2.5;
				this.baseHeight = 1;
				this.baseY = this.baseHeight / 2; // Position Y du centre de la base
				
				// Dimensions du r√©servoir (c√¥ne invers√©)
				this.tankRadius = 3;    // Rayon de la base du c√¥ne
				this.tankHeight = 4;    // Hauteur du c√¥ne
				this.tankY = 12;        // Position Y du centre du r√©servoir
				
				// Dimensions du collider
				this.calculateColliderDimensions();
				
				// Mat√©riaux
				this.concreteMaterial = new THREE.MeshStandardMaterial({
					color: 0x9c9c9c,          // Gris b√©ton
					roughness: 0.9,           // Tr√®s rugueux
					metalness: 0.1,           // Peu m√©tallique
					flatShading: true         // Rendu simple
				});
				
				this.tankMaterial = new THREE.MeshStandardMaterial({
					color: 0x9a9a9a,          // Gris m√©tal un peu plus fonc√©
					roughness: 0.7,
					metalness: 0.3,
					flatShading: true
				});
				
				// Cr√©ation des parties de la structure
				this.createTower();
				this.createWaterTank();
				
				// Configuration des collisions
				this.setupCollisions();
			}
			
			// Calculer les dimensions du collider en fonction de la structure
			calculateColliderDimensions() {
				// Rayon du collider exactement celui de la base
				this.colliderRadiusBottom = this.baseRadius;
				this.colliderRadiusTop = this.tankRadius; // Le c√¥ne est plus large au sommet
				
				// Hauteur totale (base + tour + c√¥ne)
				this.colliderHeight = this.tankY + (this.tankHeight / 2);
				
				// Position Y du collider
				this.colliderY = this.colliderHeight / 2;
			}
			
			// Cr√©er la tour en b√©ton
			createTower() {
				// Tour cylindrique principale
				const towerGeometry = new THREE.CylinderGeometry(
					this.towerTopRadius, 
					this.towerBottomRadius, 
					this.towerHeight, 
					8
				);
				this.tower = new THREE.Mesh(towerGeometry, this.concreteMaterial);
				this.tower.position.y = this.towerY;
				this.tower.castShadow = true;
				this.tower.receiveShadow = true;
				this.mesh.add(this.tower);
				
				// Base de la tour (l√©g√®rement plus large)
				const baseGeometry = new THREE.CylinderGeometry(
					this.baseRadius, 
					this.baseRadius, 
					this.baseHeight, 
					8
				);
				this.base = new THREE.Mesh(baseGeometry, this.concreteMaterial);
				this.base.position.y = this.baseY;
				this.base.castShadow = true;
				this.base.receiveShadow = true;
				this.mesh.add(this.base);
			}
			
			// Cr√©er le r√©servoir d'eau (c√¥ne invers√©)
			createWaterTank() {
				// R√©servoir en forme de c√¥ne invers√©
				const tankGeometry = new THREE.ConeGeometry(
					this.tankRadius,  // Rayon de la base du c√¥ne
					this.tankHeight,  // Hauteur du c√¥ne
					8                 // Segments
				);
				// Rotation pour l'inverser (pointe vers le bas)
				tankGeometry.rotateX(Math.PI);
				
				this.tank = new THREE.Mesh(tankGeometry, this.tankMaterial);
				this.tank.position.y = this.tankY;
				this.tank.castShadow = true;
				this.tank.receiveShadow = true;
				this.mesh.add(this.tank);
			}
			
			// Configurer les collisions
			setupCollisions() {
				// Cr√©er un collider adapt√© aux dimensions de la structure
				const colliderGeometry = new THREE.CylinderGeometry(
					this.colliderRadiusBottom,//rayon du sommet
					this.colliderRadiusBottom, //rayon de la base du cylindre
					this.colliderHeight, //hauteur du cylindre
					8	//Nombre de segments sur la circonf√©rence
				);
				const colliderMaterial = new THREE.MeshBasicMaterial({
					transparent: true,
					opacity: 0.0, // Invisible
					wireframe: true
				});
				
				this.colliderMesh = new THREE.Mesh(colliderGeometry, colliderMaterial);
				this.colliderMesh.position.y = this.colliderY;
				this.mesh.add(this.colliderMesh);
				
				// D√©finir le collider pour la d√©tection de collision
				this.collider = this.colliderMesh;
				this.hasCollision = true;
				
				// Ajouter au syst√®me de collision
				this.collisionSystem.addObject(this);
				
				// Type d'objet pour le syst√®me de collision
				this.userData = { type: 'structure' };
			}
			
			// M√©thode pour d√©truire l'objet proprement
			destroy() {
				this.scene.remove(this.mesh);
				this.collisionSystem.removeObject(this);
			}
		}

		// Classe pour l'arbre destructible avec variables de classe
		class Tree {
			constructor(scene, position, collisionSystem) {
				// Groupe principal pour contenir toute la structure
				this.mesh = new THREE.Group();
				this.mesh.position.copy(position);
				scene.add(this.mesh);
				
				// R√©f√©rences pour la gestion des collisions
				this.scene = scene;
				this.collisionSystem = collisionSystem;
				
				// Dimensions du tronc
				this.trunkHeight = 3;
				this.trunkTopRadius = 0.5;
				this.trunkBottomRadius = 0.7;
				this.trunkY = this.trunkHeight / 2; // Position Y du centre du tronc
				
				// Dimensions du feuillage
				this.foliageHeight = 5;
				this.foliageRadius = 2;
				this.foliageY = this.trunkHeight + (this.foliageHeight / 2); // Position Y du centre du feuillage
				
				// Dimensions du collider
				this.totalHeight = this.trunkHeight + this.foliageHeight;
				this.colliderY = this.totalHeight / 2;
				
				// Points de vie de l'arbre
				this.hp = 150;
				this.maxHp = 150;
				this.isAlive = true;
				
				// Cr√©er la structure de l'arbre
				this.createTree();
				
				// Configuration des collisions
				this.setupCollisions();
			}
			
			// Cr√©er la structure de l'arbre
			createTree() {
				// Mat√©riaux
				this.trunkMaterial = new THREE.MeshStandardMaterial({
					color: 0x8B4513,          // Brun pour le tronc
					roughness: 0.9,
					metalness: 0.1
				});
				
				this.foliageMaterial = new THREE.MeshStandardMaterial({
					color: 0x228B22,          // Vert pour le feuillage
					roughness: 0.8,
					metalness: 0.0
				});
				
				this.originalTrunkColor = this.trunkMaterial.color.clone();
				this.originalFoliageColor = this.foliageMaterial.color.clone();
				
				// Tronc (cylindre)
				const trunkGeometry = new THREE.CylinderGeometry(
					this.trunkTopRadius, 
					this.trunkBottomRadius, 
					this.trunkHeight, 
					8
				);
				this.trunk = new THREE.Mesh(trunkGeometry, this.trunkMaterial);
				this.trunk.position.y = this.trunkY;
				this.trunk.castShadow = true;
				this.trunk.receiveShadow = true;
				this.mesh.add(this.trunk);
				
				// Feuillage (c√¥ne)
				const foliageGeometry = new THREE.ConeGeometry(
					this.foliageRadius, 
					this.foliageHeight, 
					8
				);
				this.foliage = new THREE.Mesh(foliageGeometry, this.foliageMaterial);
				this.foliage.position.y = this.foliageY;
				this.foliage.castShadow = true;
				this.foliage.receiveShadow = true;
				this.mesh.add(this.foliage);
			}
			
			// Configurer les collisions
			setupCollisions() {
				// Un seul collider qui englobe tout l'arbre
				const colliderGeometry = new THREE.CylinderGeometry(
					this.trunkBottomRadius,  // Utiliser le rayon du feuillage en haut
					this.trunkBottomRadius, // Utiliser le rayon du tronc en bas
					this.totalHeight,
					8	//nombre de segments
				);
				
				const colliderMaterial = new THREE.MeshBasicMaterial({
					transparent: true,
					opacity: 0.0, // Invisible
					wireframe: true
				});
				
				this.colliderMesh = new THREE.Mesh(colliderGeometry, colliderMaterial);
				this.colliderMesh.position.y = this.colliderY;
				this.mesh.add(this.colliderMesh);
				
				// D√©finir le collider pour la d√©tection de collision
				this.collider = this.colliderMesh;
				this.hasCollision = true;
				
				// Ajouter au syst√®me de collision
				this.collisionSystem.addObject(this);
				
				// Type d'objet pour le syst√®me de collision
				this.userData = { type: 'tree' };
			}
			
			// M√©thode pour recevoir des d√©g√¢ts
			takeDamage(amount) {
				// Trouver le propri√©taire du projectile qui a caus√© les d√©g√¢ts
				if (this.isMainPlayer && projectileData && projectileData.ownerId) {
					// Stocker le joueur qui nous a tir√© dessus
					if (otherPlayers[projectileData.ownerId]) {
						this.lastKiller = otherPlayers[projectileData.ownerId];
					}
				}
				
				if (!this.isAlive) return;
							
				// Afficher le texte des d√©g√¢ts
				//createDamageText(this.mesh.position, amount); Mis en commentaire pour √©viter de voir le message deux fois
				
				// Effet visuel de d√©g√¢ts
				this.showDamageEffect();
			}
			
			// Effet visuel pour les d√©g√¢ts
			showDamageEffect() {
				// Changement temporaire de couleur pour indiquer les d√©g√¢ts
				this.trunkMaterial.color.set(0xff0000);  // Rouge quand touch√©
				this.foliageMaterial.color.set(0xff0000);  // Rouge quand touch√©
				
				// Revenir aux couleurs d'origine apr√®s un d√©lai
				setTimeout(() => {
					// Utiliser les couleurs originales stock√©es en tant que propri√©t√©s
					this.trunkMaterial.color.copy(this.originalTrunkColor);
					this.foliageMaterial.color.copy(this.originalFoliageColor);
				}, 200);
			}
			
			// M√©thode appel√©e quand l'arbre est d√©truit
			die() {
				if (!this.isAlive) return; // √âviter de d√©clencher plusieurs fois
				
				this.isAlive = false;
				
				// Supprimer l'arbre de la sc√®ne
				this.destroy();
			}
			
			// M√©thode pour d√©truire l'objet proprement
			destroy() {
				this.scene.remove(this.mesh);
				this.collisionSystem.removeObject(this);
			}
		}		
		
		// Classe pour la carte de jeu
        class GameMap {
            constructor(scene, collisionSystem) {
                this.width = 200;  // Largeur de la carte
                this.height = 200; // Hauteur de la carte
                this.collisionSystem = collisionSystem;
                this.scene = scene;
                this.structures = [];
				this.trees=[];

				// Cr√©er un sol circulaire
				const floorRadius = this.width / 2; // Rayon = moiti√© de la largeur
				const floorSegments = 64; // Nombre de segments pour le cercle
				const floorGeometry = new THREE.CircleGeometry(floorRadius, floorSegments);
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4b6043,
                    side: THREE.DoubleSide,
                    roughness: 0.8
                });
                this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
                this.floor.rotation.x = Math.PI / 2; // Rotation pour que le plan soit horizontal
                this.floor.position.y = 0;
                scene.add(this.floor);
                
                // Ajouter le sol au syst√®me de collision
                this.floor.userData.type = 'floor';
                this.collider = this.floor;  // Le collider est le mesh lui-m√™me
                this.hasCollision = false;    // Activer les collisions
                this.userData = { type: 'floor' };
                this.collisionSystem.addObject(this);
                
                // Cr√©er les bordures
                this.createBorders(scene);
                
                // Gestion des processeurs
                this.processors = [];
                this.processorTypes = [
                    'hp', 'resistance', 'attack', 'attackSpeed', 
                    'range', 'speed', 'repairSpeed'
                ];
                
                // Fr√©quence d'apparition pour chaque type (en millisecondes)
                this.spawnRates = {
                    hp: 1000,         // 1 par seconde
                    resistance: 1000,
                    attack: 1000,
                    attackSpeed: 1000,
                    range: 1000,
                    speed: 1000,
                    repairSpeed: 1000
                };
                
                // Compteurs de temps pour le spawn de chaque type
                this.spawnCounters = {};
                this.processorTypes.forEach(type => {
                    this.spawnCounters[type] = 0;
                });
                
                // Nombre maximum de processeurs
                this.maxProcessors = 10000;
                
                // Gestion des canons
                this.cannons = [];
                this.cannonSpawnRate = 5000; // 5 secondes
                this.cannonSpawnCounter = 0;
            }
            
            // Cr√©er des bordures visuelles autour de la carte
            createBorders(scene) {
				const borderMaterial = new THREE.MeshStandardMaterial({ 
									color: 0xd2b48c, // Couleur beige-ocre
									roughness: 0.9,  // Plus rugueux pour ressembler √† la pierre ancienne
									metalness: 0.1   // Faible m√©tallicit√© pour la pierre
								});
                
                // Hauteur des murs
                const wallHeight = 0.4;
                
				// Cr√©er une bordure circulaire
				const radius = this.width / 2; // Rayon du cercle = moiti√© de la largeur
				const segments = 64; // Nombre de segments pour cr√©er le cercle
				const wallThickness = 1;
				
				// Cr√©er une g√©om√©trie tubulaire pour la bordure circulaire
				const circleShape = new THREE.Shape();
				circleShape.absarc(0, 0, radius, 0, Math.PI * 2, false);
				
				// Cr√©er un trou √† l'int√©rieur pour rendre la bordure creuse
				const holeShape = new THREE.Shape();
				holeShape.absarc(0, 0, radius - wallThickness, 0, Math.PI * 2, true);
				circleShape.holes.push(holeShape);
				
				// Extrusion de la forme pour cr√©er une bordure 3D
				const extrudeSettings = {
					steps: 1,
					depth: wallHeight,
					bevelEnabled: false
				};
				
				const borderGeometry = new THREE.ExtrudeGeometry(circleShape, extrudeSettings);
				this.circleBorder = new THREE.Mesh(borderGeometry, borderMaterial);
				this.circleBorder.position.y = 0.4;
				this.circleBorder.rotation.x = Math.PI / 2; // Rotation pour que le cercle soit horizontal
				this.circleBorder.userData.type = 'wall';
				scene.add(this.circleBorder);
				
				// Ajouter au syst√®me de collision
				this.circleBorderObj = {
					collider: this.circleBorder,
					hasCollision: true,
					userData: { type: 'wall' }
				};
				this.collisionSystem.addObject(this.circleBorderObj);
                

            }
            
			
			// Cr√©er des arbres
			createTrees() {
				// Cr√©er quelques arbres √† des positions al√©atoires
				const treeCount = 40; // Nombre d'arbres √† cr√©er
				
				for (let i = 0; i < treeCount; i++) {
					// Position al√©atoire sur la carte (√©viter le centre o√π se trouve la tour d'eau)
					let x, z;
					do {
						x = (Math.random() * this.width - this.width / 2) * 0.8;
						z = (Math.random() * this.height - this.height / 2) * 0.8;
					} while (Math.sqrt(x*x + z*z) < 20); // √âviter le centre
					
					const tree = new Tree(
						this.scene,
						new THREE.Vector3(x, 0, z),
						this.collisionSystem
					);
					
					this.trees.push(tree);
					this.structures.push(tree);
				}
			}
			
			// Cr√©er les structures
			createStructures() {
				// Cr√©er un ch√¢teau d'eau au centre de la carte
				const waterTower = new WaterTower(
					this.scene,
					new THREE.Vector3(0, 0, 0),
					this.collisionSystem
				);
				this.structures.push(waterTower);
				
				//Cr√©er des arbres
				this.createTrees();
			}
	
            // M√©thode pour cr√©er un processeur al√©atoirement sur la carte
            spawnProcessor(type) {
                // V√©rifier si on a atteint le nombre maximum de processeurs
                if (this.processors.length >= this.maxProcessors) {
                    return;
                }
                
                // Position al√©atoire sur la carte
                const x = Math.random() * this.width - this.width / 2;
                const z = Math.random() * this.height - this.height / 2;
                const y = 0.5; // Hauteur augment√©e pour meilleure visibilit√©
                
                const position = new THREE.Vector3(x, y, z);
                
                // Cr√©er le processeur
                const processor = new Processor(this.scene, position, type, this.collisionSystem);
                this.processors.push(processor);
                
                return processor;
            }
            
            // M√©thode pour cr√©er un canon
            spawnCannon() {
                // V√©rifier si on a atteint le nombre maximum de canons (moins que les processeurs)
                if (this.cannons.length >= 20) {
                    return;
                }
                
                // Position al√©atoire sur la carte
                const x = Math.random() * this.width - this.width / 2;
                const z = Math.random() * this.height - this.height / 2;
                const y = 0.5; // Hauteur augment√©e pour meilleure visibilit√©
                
                const position = new THREE.Vector3(x, y, z);
                
                // Cr√©er le canon
                const cannon = new Cannon(this.scene, position, this.collisionSystem);
                this.cannons.push(cannon);
                
                return cannon;
            }
            
   
            // M√©thode pour supprimer un canon de la liste
            removeCannon(cannon) {
                const index = this.cannons.indexOf(cannon);
                if (index !== -1) {
                    this.cannons.splice(index, 1);
                }
            }
            
            
            // Mettre √† jour les processeurs existants et cr√©er de nouveaux si n√©cessaire
            updateProcessors(deltaTime) {
                // Mettre √† jour les processeurs existants
                for (let i = this.processors.length - 1; i >= 0; i--) {
                    this.processors[i].update();
                }
            }
            
            // Mettre √† jour les canons
            updateCanons(deltaTime) {
                // Mise √† jour des canons existants
                for (let i = this.cannons.length - 1; i >= 0; i--) {
                    this.cannons[i].update();
                }                
            }
            
            // Supprimer un processeur de la liste
            removeProcessor(processor) {
                const index = this.processors.indexOf(processor);
                if (index !== -1) {
                    this.processors.splice(index, 1);
                }
            }
            
            // Faire appara√Ætre plusieurs processeurs √† un endroit donn√© (lors de la mort d'un joueur)
            spawnProcessorsAtLocation(position, typeAmounts) {
                Object.entries(typeAmounts).forEach(([type, amount]) => {
                    for (let i = 0; i < amount; i++) {
                        // Cr√©er un nouveau processeur √† la position donn√©e
                        const randomOffset = new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            0.1,
                            (Math.random() - 0.5) * 2
                        );
                        
                        const spawnPos = position.clone().add(randomOffset);
                        spawnPos.y = 0.5; // S'assurer que les processeurs largu√©s sont aussi en hauteur
                        const processor = new Processor(this.scene, spawnPos, type, this.collisionSystem);
                        this.processors.push(processor);
                        
                    }
                });
            }
        }

		// Classe pour le robot du joueur
		class Player {
			constructor(scene, gameMap, collisionSystem, playerId = null, isMainPlayer = true) {
				// Propri√©t√©s multijoueur
				this.playerId = playerId || `player-${Math.random().toString(36).substr(2, 9)}`;
				this.isMainPlayer = isMainPlayer;
				this.username = username || `Robot-${Math.floor(Math.random() * 1000)}`; // Utiliser le nom d√©fini lors de la connexion
				
				// Groupe pour contenir toutes les parties du robot
				this.mesh = new THREE.Group();
				scene.add(this.mesh);
				
				// Propri√©t√©s de mouvement
				this.speed = 0.04;  
				this.rotationSpeed = 0.02; // Vitesse de rotation
				this.direction = new THREE.Vector3(0, 0, -1); // Direction initiale (vers le haut de l'√©cran)
				
				// Initialiser bodyParts avant de cr√©er les composants du robot
				this.bodyParts = [];
				
				// Dimensions du corps (r√©f√©rence pour d'autres calculs)
				this.bodyWidth = 0.5;
				this.bodyHeight = 1;
				this.bodyDepth = 0.5;
				this.frameThickness = 0.08;
				this.headHeight = 0.15; // Hauteur de la base de la t√™te
				this.bottomThickness = this.frameThickness * 6; // √âpaisseur du panneau inf√©rieur
				
				// Dimensions des colonnes de processeurs (d√©finies comme propri√©t√©s de classe)
				this.columnWidth = 0.04;
				this.columnDepth = 0.15;
				
				// La hauteur des colonnes sera calcul√©e dans createRobotBody() 
				// une fois qu'on aura la position exacte des panneaux
				this.columnHeight = 0;
				this.columnBottomY = 0;
				this.columnTopY = 0;
				
				// Cr√©er le corps du robot
				this.createRobotBody();
				
				// Cr√©er les roues
				this.createTracks();
				
				// Cr√©er le canon
				this.createCannon();
				
				// Cr√©er le collider APR√àS avoir cr√©√© toutes les parties du robot
				this.createCollider();
				
				// Stocker les couleurs originales pour l'effet de d√©g√¢ts
				this.storeOriginalColors();

				// Propri√©t√©s de collision
				this.hasCollision = true;   // Activer les collisions
				
				// R√©f√©rence √† la sc√®ne, la carte et au syst√®me de collision
				this.scene = scene;
				this.gameMap = gameMap;
				this.collisionSystem = collisionSystem;
				this.collisionSystem.addObject(this);
				
				// Position initiale al√©atoire sur la carte
				this.setRandomPosition();
				
				// Projectiles actifs
				this.projectiles = [];
				
				// Nouvelles propri√©t√©s de combat
				this.hp = 100;             // Points de vie
				this.maxHp = 100;          // Points de vie maximum
				this.resistance = 10;      // R√©sistance aux d√©g√¢ts (d√©fense)
				this.attack = 10;          // Puissance d'attaque
				this.attackSpeed = 0.5;    // Attaques par seconde
				this.range = 10;           // Port√©e d'attaque
				this.repairSpeed = 0.5;    // Vitesse de r√©paration (HP r√©cup√©r√©s par seconde)
				this.isAlive = true;       // √âtat du joueur
				
				// √âchelle initiale pour la croissance
				this.baseScale = 1.0;
				
				// Compteurs pour les processeurs ramass√©s
				this.processorCounts = {
					hp: 0,
					resistance: 0,
					attack: 0,
					attackSpeed: 0,
					range: 0,
					speed: 0,
					repairSpeed: 0
				};
				
				// Total des processeurs pour tous les types
				this.totalProcessors = 0;
				
				// Gestion du cooldown d'attaque
				this.canAttack = true;
				this.lastAttackTime = 0;
				this.attackCooldown = 1000 / this.attackSpeed; // Conversion en millisecondes
				
                // Propri√©t√©s pour les canons
                this.sideCannons = []; // Canons suppl√©mentaires sur les c√¥t√©s
                this.maxSideCannons = 4; // Nombre maximum de canons suppl√©mentaires
                this.sideCannonsGroup = new THREE.Group(); // Groupe pour contenir les canons lat√©raux
                this.mesh.add(this.sideCannonsGroup);
                
				// Mise √† jour de l'interface utilisateur (uniquement pour le joueur principal)
				if (this.isMainPlayer) {
					this.updateUI();
				}
			}
			
			// M√©thode pour cr√©er le collider
			createCollider() {
				// Bo√Æte de collision correspondant exactement au corps du robot
				const colliderGeometry = new THREE.BoxGeometry(
					this.bodyWidth + this.frameThickness,
					this.bodyHeight + (this.frameThickness/2) + (this.bottomThickness/2)+ this.headHeight, 
					this.bodyDepth
				);
				
				const colliderMaterial = new THREE.MeshBasicMaterial({ 
					transparent: true,
					opacity: 0.0, // Invisible par d√©faut
					wireframe: true,
					color: 0xff0000 // Couleur de base rouge
				});
				
				this.colliderMesh = new THREE.Mesh(colliderGeometry, colliderMaterial);
				this.colliderMesh.position.y = (this.bodyHeight+ this.headHeight+0.4)/2; // Centr√© verticalement par rapport au robot
				this.mesh.add(this.colliderMesh);
				
				// D√©finir le collider pour la d√©tection de collision
				this.collider = this.colliderMesh;
			}
			
			// D√©finir une position al√©atoire sur la carte
			setRandomPosition() {
			  const mapRadius = this.gameMap.width / 2; // Rayon de la carte
			  const minRadius = mapRadius * 0.90; // 90% du rayon
			  const maxRadius = mapRadius * 0.95; // 95% du rayon
			  
			  // G√©n√©rer une position al√©atoire dans une zone annulaire
			  const angle = Math.random() * Math.PI * 2; // Angle al√©atoire
			  const radius = minRadius + Math.random() * (maxRadius - minRadius);
			  
			  this.mesh.position.x = Math.cos(angle) * radius;
			  this.mesh.position.y = 0.01; // L√©g√®rement au-dessus du sol
			  this.mesh.position.z = Math.sin(angle) * radius;
			}

			// M√©thode pour d√©placer le robot
			move(keys) {
				if (!this.isAlive) return;
				
				// Sauvegarde de la position actuelle pour pouvoir revenir en arri√®re si n√©cessaire
				const oldPosition = this.mesh.position.clone();
				
				// Rotation √† gauche/droite
				if (keys.ArrowLeft) {
					// Tourner le robot
					this.mesh.rotation.y += this.rotationSpeed;
					
					// Mettre √† jour le vecteur de direction
					this.direction.set(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
					
					// Animer les roues (rotation des roues)
					this.animateWheelsTurn(-1);
				}
				if (keys.ArrowRight) {
					// Tourner le robot
					this.mesh.rotation.y -= this.rotationSpeed;
					
					// Mettre √† jour le vecteur de direction
					this.direction.set(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
					
					// Animer les roues (rotation des roues)
					this.animateWheelsTurn(1);
				}
				
				// D√©placement avant/arri√®re selon l'orientation
				if (keys.ArrowUp) {
					this.mesh.position.add(this.direction.clone().multiplyScalar(this.speed));
					
					// Animer les roues (mouvement vers l'avant)
					this.animateWheelsMovement(1);
				}
				if (keys.ArrowDown) {
					this.mesh.position.add(this.direction.clone().multiplyScalar(-this.speed));
					
					// Animer les roues (mouvement vers l'arri√®re)
					this.animateWheelsMovement(-1);
				}
				
				// V√©rifier les collisions
				const collisions = this.collisionSystem.checkCollisionForObject(this);
				
			    // Traiter les collisions
				if (collisions.length > 0) {
					this.handleCollisions(collisions, oldPosition);
					
					// R√©initialiser les segments de chenilles UNIQUEMENT apr√®s avoir r√©solu toutes les collisions
					this.resetTrackSegmentsToInitialPositions();
				}
				
			    // Si c'est le joueur principal, envoyer la mise √† jour au serveur
				if (this.isMainPlayer && (keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight)) {
					socket.emit('playerUpdate', {
						position: this.mesh.position,
						rotation: this.mesh.rotation.y,
						direction: this.direction,
						isAlive: this.isAlive
					});
				}
			}
			
			// M√©thode pour g√©rer les collisions
			handleCollisions(collisions, oldPosition) {
			
				// S√©parer les collisions par type
				const blockingCollisions = [];
				const processorCollisions = [];
				const cannonCollisions = [];
				const playerCollisions = [];  
				
				collisions.forEach(obj => {
					if (obj instanceof Processor) {
						processorCollisions.push(obj);
					} else if (obj instanceof Cannon) {
						cannonCollisions.push(obj);
					} else if (obj instanceof Player) {  // Ajouter ce cas pour les joueurs
						playerCollisions.push(obj);
					} else if (!(obj.userData && obj.userData.type === 'floor')) {
						blockingCollisions.push(obj);
					}
				});
				
				// Traiter les collectibles
				processorCollisions.forEach(processor => this.collectProcessor(processor));
				cannonCollisions.forEach(cannon => {
					if (this.addSideCannon()) {
						cannon.destroy();
						this.gameMap.removeCannon(cannon);
					}
				});
				
				// Traiter les collisions avec les joueurs en premier
				if (playerCollisions.length > 0) {
					this.handlePlayerCollisions(playerCollisions, oldPosition);
				}
				
				// G√©rer les collisions physiques avec les obstacles
				if (blockingCollisions.length > 0) {
					this.handlePhysicalCollisions(blockingCollisions, oldPosition);
				}
			}

			handlePlayerCollisions(playerCollisions, oldPosition) {
				// Direction de mouvement actuelle
				const movementDirection = new THREE.Vector3()
					.subVectors(this.mesh.position, oldPosition)
					.normalize();
				
				// Si pas de mouvement significatif, ignorer
				if (movementDirection.length() < 0.001) return;
				
				// V√©rifier les collisions avec d'autres joueurs
				let needsPositionReset = false;
				
				playerCollisions.forEach(otherPlayer => {
					if (otherPlayer === this) return; // Ignorer la collision avec soi-m√™me
					
					// Calculer le vecteur entre les deux joueurs
					const pushDirection = new THREE.Vector3()
						.subVectors(this.mesh.position, otherPlayer.mesh.position)
						.normalize();
					
					// Distance entre les joueurs
					const distance = this.mesh.position.distanceTo(otherPlayer.mesh.position);
					
					// D√©terminer le rayon combin√© (en tenant compte de l'√©chelle des joueurs)
					const thisRadius = this.bodyWidth * this.baseScale * 0.75;
					const otherRadius = this.bodyWidth * (otherPlayer.baseScale || 1.0) * 0.75;
					const minDistance = thisRadius + otherRadius;
					
					// Si la distance est inf√©rieure √† la distance minimale, il y a collision
					if (distance < minDistance) {
						// Calculer la force de r√©pulsion
						const overlap = minDistance - distance;
						
						// Pour les joueurs de taille tr√®s diff√©rente, le plus petit rebondit plus
						const thisScale = this.baseScale || 1.0;
						const otherScale = otherPlayer.baseScale || 1.0;
						const scaleFactor = Math.min(1, thisScale / otherScale);
						
						// Appliquer la force de r√©pulsion (seulement sur ce joueur)
						const pushStrength = overlap * 1.1 * scaleFactor; // Force l√©g√®rement sup√©rieure √† l'overlap
						
						// Revenir √† l'ancienne position puis appliquer une l√©g√®re pouss√©e dans la direction oppos√©e
						this.mesh.position.copy(oldPosition);
						this.mesh.position.addScaledVector(pushDirection, pushStrength);
						
						needsPositionReset = true;
					}
				});
				
				// Si une collision a √©t√© r√©solue, informer le serveur de la nouvelle position
				if (needsPositionReset && this.isMainPlayer) {
					socket.emit('playerUpdate', {
						position: this.mesh.position,
						rotation: this.mesh.rotation.y,
						direction: this.direction
					});
				}
			}

			handlePhysicalCollisions(blockingCollisions, oldPosition) {
				// Direction de mouvement actuelle
				const movementDirection = new THREE.Vector3()
					.subVectors(this.mesh.position, oldPosition)
					.normalize();
				
				// Distance parcourue
				const distanceMoved = this.mesh.position.distanceTo(oldPosition);
				
				if (distanceMoved < 0.001) return; // Pas de mouvement significatif
				
				// Cr√©er un raycaster pour la d√©tection pr√©cise des collisions
				const raycaster = new THREE.Raycaster(
					oldPosition,
					movementDirection,
					0,
					distanceMoved * 1.1 // L√©g√®rement plus long pour s√©curit√©
				);
				
				// Collecter tous les objets de collision
				const colliderMeshes = blockingCollisions.map(obj => obj.collider);
				
				// Effectuer le raycasting
				const intersects = raycaster.intersectObjects(colliderMeshes, false);
				
				if (intersects.length > 0) {
					// Trouver l'intersection la plus proche
					const closestIntersect = intersects[0];
					
					// Calculer le point de contact
					const contactPoint = closestIntersect.point;
					
					// Obtenir la normale de surface au point d'impact
					const surfaceNormal = closestIntersect.face.normal.clone();
					
					// Si l'objet a une matrice de rotation, appliquer cette rotation √† la normale
					if (closestIntersect.object.parent) {
						const parentRotation = new THREE.Matrix4();
						parentRotation.extractRotation(closestIntersect.object.parent.matrixWorld);
						surfaceNormal.applyMatrix4(parentRotation);
					}
					
					// Calculer le vecteur de r√©flexion (rebond)
					const reflectionVector = movementDirection.clone()
						.reflect(surfaceNormal)
						.normalize();
					
					// D√©composer le mouvement en composantes parall√®le et perpendiculaire √† la surface
					const dotProduct = movementDirection.dot(surfaceNormal);
					const parallelComponent = surfaceNormal.clone().multiplyScalar(dotProduct);
					const perpendicularComponent = new THREE.Vector3()
						.subVectors(movementDirection, parallelComponent);
					
					// Friction de surface (r√©duire la composante parall√®le)
					const friction = 0.8; // 0 = glissant, 1 = totalement bloqu√©
					perpendicularComponent.multiplyScalar(1 - friction);
					
					// Calculer la nouvelle direction (glissement le long de la surface)
					const newDirection = perpendicularComponent.normalize();
					
					// Calculer la nouvelle position avec glissement
					// Placer le joueur l√©g√®rement avant le point de contact
					const safetyMargin = 0.05;
					const distanceToContact = oldPosition.distanceTo(contactPoint) - safetyMargin;
					
					// Positionner au point de contact s√©curis√©
					this.mesh.position.copy(oldPosition)
						.addScaledVector(movementDirection, distanceToContact);
					
					// Appliquer le glissement (seulement une petite fraction du mouvement original)
					const slideDistance = distanceMoved * 0.3 * (1 - friction);
					this.mesh.position.addScaledVector(newDirection, slideDistance);
					
					// Maintenir la hauteur Y
					this.mesh.position.y = oldPosition.y;
					
					// Effet visuel facultatif: petite secousse lors de l'impact
					this.showCollisionEffect(surfaceNormal);
				}
			}

			showCollisionEffect(normal) {
				// Intensit√© de l'effet bas√©e sur la normale d'impact
				const intensity = Math.abs(normal.dot(this.direction)) * 0.3;
				if (intensity < 0.1) return; // Ignorer les impacts faibles
				
				// Animation de secousse
				const originalPosition = this.bodyGroup.position.clone();
				
				// Calculer le vecteur de secousse perpendiculaire √† la direction de d√©placement
				const shakeVector = new THREE.Vector3()
					.crossVectors(this.direction, new THREE.Vector3(0, 1, 0))
					.normalize()
					.multiplyScalar(intensity * 0.05);
				
				// S√©quence de secousse
				this.bodyGroup.position.add(shakeVector);
				
				setTimeout(() => {
					this.bodyGroup.position.copy(originalPosition);
					setTimeout(() => {
						this.bodyGroup.position.sub(shakeVector.multiplyScalar(0.7));
						setTimeout(() => {
							this.bodyGroup.position.copy(originalPosition);
						}, 50);
					}, 50);
				}, 50);
			}
			
			// Collecter un processeur
			collectProcessor(processor) {
				const type = processor.type;
				const boost = processor.boost;
				
		        // Informer le serveur de la collecte
				if (this.isMainPlayer) {
					socket.emit('processorCollected', {
						processorId: processor.id || '',
						type: type,
						boost: boost
					});
				}
				
				// Augmenter le compteur du type correspondant
				const oldCount = this.processorCounts[type];
				this.processorCounts[type]++;
				this.totalProcessors++;
				
				// Texte et couleur selon le type de processeur
				let boostText = "";
				let textColor = "#FFFFFF";
				
				// Mettre √† jour les statistiques en fonction du type
				switch(type) {
					case 'hp':
						this.maxHp += boost;
						// Augmenter √©galement les HP actuels
						this.hp += boost;
						boostText = "HP+";
						textColor = "#00ff00"; // Vert
						break;
					case 'resistance':
						this.resistance += boost;
						boostText = "DEF+";
						textColor = "#ffa500"; // Orange
						break;
					case 'attack':
						this.attack += boost;
						boostText = "ATK+";
						textColor = "#ff0000"; // Rouge
						break;
					case 'attackSpeed':
						this.attackSpeed += boost;
						// Mettre √† jour le cooldown d'attaque
						this.attackCooldown = 1000 / this.attackSpeed;
						boostText = "ATS+";
						textColor = "#ffff00"; // Jaune
						break;
					case 'range':
						this.range += boost;
						boostText = "RNG+";
						textColor = "#0000ff"; // Bleu
						break;
					case 'speed':
						this.speed += boost;
						boostText = "SPD+";
						textColor = "#4b0082"; // Indigo
						break;
					case 'repairSpeed':
						this.repairSpeed += boost;
						boostText = "RPS+";
						textColor = "#8a2be2"; // Violet
						break;
				}
				
				// Cr√©er l'effet visuel de texte flottant
				this.createFloatingText(processor.mesh.position, boostText, textColor);
				
				// Faire grandir le robot
				this.baseScale += 0.005; // +0.5% par processeur
				this.updateScale();
				
				// Mettre √† jour les indicateurs visuels
				this.updateProcessorIndicators();
				
				// V√©rifier si on vient d'atteindre un multiple de 10
				const newCount = this.processorCounts[type];
				if (Math.floor(newCount / 10) > Math.floor(oldCount / 10)) {
					// Faire pulser la colonne uniquement si on vient de franchir un palier
					this.pulseProcessorColumn(this.processorColumns[type], type);
				}
				
				// Mettre √† jour l'interface utilisateur
				this.updateUI();
				
				// D√©truire le processeur
				processor.destroy();
				this.gameMap.removeProcessor(processor);
			}
			
			addSideCannon() {
				// V√©rifier si on a atteint le nombre maximum de canons
				if (this.sideCannons.length >= this.maxSideCannons) {
					console.log("Nombre maximum de canons atteint");
					return false;
				}
				
				const cannonIndex = this.sideCannons.length;
				
				// Cr√©er un nouveau groupe pour ce canon
				const cannonGroup = new THREE.Group();
				
				// D√©terminer le c√¥t√© (gauche ou droit) et la rang√©e
				const isLeftSide = cannonIndex % 2 === 0; // Pair = gauche, Impair = droite
				const rowIndex = Math.floor(cannonIndex / 2); // D√©termine la rang√©e
				
				// Positions de base (avant application de l'√©chelle)
				const xOffset = isLeftSide ? -0.25 : 0.25; // Position lat√©rale
				const yOffset = 0.9 - (rowIndex * 0.45); // Hauteur variable
				const zOffset = -0.2; // Espacement avant-arri√®re

				cannonGroup.position.set(
					xOffset,
					yOffset, 
					zOffset
				);
				
				// Orienter le canon vers l'avant
				cannonGroup.rotation.y = 0;
				
				// Mat√©riaux
				const barrelMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x666666,
					roughness: 0.4,
					metalness: 0.8
				});
				
				const baseMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x444444,
					roughness: 0.6,
					metalness: 0.6
				});
				
				// Base du canon
				const baseGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.2);
				const base = new THREE.Mesh(baseGeometry, baseMaterial);
				cannonGroup.add(base);
				
				// Canon
				const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.2, 10);
				barrelGeometry.rotateX(Math.PI / 2); // Orienter horizontalement
				const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
				barrel.position.z = -0.12; // Positionner √† l'avant
				cannonGroup.add(barrel);
				
				// Ajouter le canon au groupe des canons lat√©raux
				this.sideCannonsGroup.add(cannonGroup);
				
				// Ajouter √† la liste des canons avec une r√©f√©rence √† son groupe et au canon
				this.sideCannons.push({
					group: cannonGroup,
					barrel: barrel,
					basePosition: barrel.position.z, // Pour l'animation de recul
					initialPosition: barrel.position.clone() // Stockage de la position initiale
				});
				
				// Ajouter aux parties du corps pour les effets de d√©g√¢ts
				this.bodyParts.push(base, barrel);
				
				// Si les couleurs originales ont d√©j√† √©t√© stock√©es, ajouter aussi les couleurs des nouveaux canons
				if (this.originalBodyColors) {
					this.originalBodyColors.push(base.material.color.clone());
					this.originalBodyColors.push(barrel.material.color.clone());
				}
				
				// Cr√©er un texte flottant pour indiquer l'ajout du canon
				this.createFloatingText(this.mesh.position, "CANON+", "#ffffff");
				
				return true;
			}
            
			// Mettre √† jour l'√©chelle du robot
			updateScale() {
			    // R√©initialiser tous les reculs en cours avant de changer l'√©chelle
			    this.resetAllRecoils();
				
				// Appliquer la nouvelle √©chelle
				this.mesh.scale.set(this.baseScale, this.baseScale, this.baseScale);
				
				// R√©initialiser toutes les positions de r√©f√©rence
				this.storeAllInitialPositions();
				
				// R√©initialiser les positions des colonnes de processeur
				this.resetProcessorColumnPositions();
				
				// Signaler au syst√®me de collision que notre collider a chang√©
				if (this.collisionSystem) {
					this.collisionSystem.removeObject(this);
					this.collisionSystem.addObject(this);
				}
			}
			
			// Animation des chenilles lors du mouvement avant/arri√®re
			animateWheelsMovement(direction) {
				// Si les positions initiales ne sont pas stock√©es, les enregistrer maintenant
				if (!this.leftTrackInitialPositions || !this.rightTrackInitialPositions) {
					this.storeAllInitialPositions();
				}

				// Animer uniquement les segments de chenilles
				if (this.leftTrackSegments && this.rightTrackSegments) {
					// D√©caler les segments vers l'avant ou l'arri√®re
					const segmentShift = 0.003 * direction * (this.speed / 0.02);
					
					// Animer les segments gauches et droits de mani√®re identique lors du mouvement droit
					[this.leftTrackSegments, this.rightTrackSegments].forEach(segments => {
						segments.forEach(segment => {
							segment.position.z += segmentShift;
							
							// Si le segment sort des limites, le replacer √† l'autre extr√©mit√©
							const limit = 0.35; // Moiti√© de la longueur de la chenille
							if (segment.position.z > limit) {
								segment.position.z = -limit;
							} else if (segment.position.z < -limit) {
								segment.position.z = limit;
							}
						});
					});
				}
			}
			
			// Animation des chenilles lors de la rotation
			animateWheelsTurn(direction) {
				// Si les positions initiales ne sont pas stock√©es, les enregistrer maintenant
				if (!this.leftTrackInitialPositions || !this.rightTrackInitialPositions) {
					this.storeAllInitialPositions();
				}

				// Simuler un diff√©rentiel de rotation des chenilles lors d'un virage
				if (this.leftTrackSegments && this.rightTrackSegments) {
					// Le c√¥t√© ext√©rieur se d√©place plus vite que le c√¥t√© int√©rieur
					const leftShift = direction > 0 ? -0.001 : -0.004;
					const rightShift = direction > 0 ? -0.004 : -0.001;
					
					// Animer les segments gauches
					this.leftTrackSegments.forEach(segment => {
						segment.position.z += leftShift;
						const limit = 0.35;
						if (segment.position.z > limit) {
							segment.position.z = -limit;
						} else if (segment.position.z < -limit) {
							segment.position.z = limit;
						}
					});
					
					// Animer les segments droits
					this.rightTrackSegments.forEach(segment => {
						segment.position.z += rightShift;
						const limit = 0.35;
						if (segment.position.z > limit) {
							segment.position.z = -limit;
						} else if (segment.position.z < -limit) {
							segment.position.z = limit;
						}
					});
				}
			}
			
			// M√©thode pour g√©rer l'attaque
			doAttack(keys, time) {
				if (!this.isAlive) return false;
				
				// Mettre √† jour l'orientation du canon pour qu'il suive la direction du joueur
				this.updateCannonDirection();
				
				// V√©rifier si le joueur appuie sur Ctrl gauche et si l'attaque est disponible
				if (keys.Control && this.canAttack) {
					console.log("Attaque! Puissance:", this.attack, "Port√©e:", this.range);
					
					// Cr√©er un projectile dans la direction que regarde le joueur
					try {
						const projectile = this.fireProjectile();
						
						// V√©rifier que le projectile a bien √©t√© cr√©√©
						if (projectile && projectile.group) {
							// Si c'est le joueur principal, informer le serveur
							if (this.isMainPlayer) {
								socket.emit('playerShoot', {
								    projectileId: projectile.id, // Ajouter l'ID temporaire
									position: projectile.group.position,
									direction: projectile.direction,
									damage: this.attack,
									range: this.range
								});
							}
						}
					} catch (error) {
						console.error("Erreur lors du tir:", error);
					}
					
					// Mettre en place le cooldown
					this.canAttack = false;
					this.lastAttackTime = time;
					
					return true; // Une attaque a √©t√© effectu√©e
				}
				
				// V√©rifier si le cooldown est termin√©
				if (!this.canAttack && (time - this.lastAttackTime) >= this.attackCooldown) {
					this.canAttack = true;
				}
				
				// Mettre √† jour les projectiles
				this.updateProjectiles();
				
				return false;
			}
			
			// Mettre √† jour l'orientation du canon
			updateCannonDirection() {
				// Le canon pointe toujours dans la m√™me direction que le robot
				// La rotation est d√©j√† g√©r√©e par la hi√©rarchie des objets 3D
				// Mais on pourrait ajouter ici des animations suppl√©mentaires
			}
			
			// Cr√©er un projectile
            fireProjectile() {
                // Utiliser la direction actuelle du joueur
                const direction = this.direction.clone();
                
                // Tir du canon simple
                this.fireFromBarrel(this.cannonBarrel, direction);
                    
                // Effet de recul du canon
                this.showRecoilEffect();
                
                // Tir des canons lat√©raux
                this.sideCannons.forEach(cannon => {
                    // Direction de tir bas√©e sur la rotation du canon
                    const cannonDirection = new THREE.Vector3(0, 0, -1);
                    cannonDirection.applyQuaternion(cannon.group.getWorldQuaternion(new THREE.Quaternion()));
                    
                    // Position mondiale du bout du canon
                    const barrelTip = new THREE.Vector3(0, 0, cannon.basePosition - 0.1);
                    const worldPosition = new THREE.Vector3();
                    
                    // Convertir la position locale en position mondiale
                    cannon.group.updateMatrixWorld();
                    worldPosition.copy(barrelTip).applyMatrix4(cannon.group.matrixWorld);
                    
                    // Cr√©er le projectile
                    const projectile = new Projectile(this.scene, worldPosition, cannonDirection, this, this.collisionSystem);
                    this.projectiles.push(projectile);
                    
                    // Effet de recul
                    this.showSideCannonRecoilEffect(cannon);
                });
            }
            
            // M√©thode auxiliaire pour tirer depuis un canon sp√©cifique
			fireFromBarrel(barrel, direction) {
				// Position mondiale du bout du canon
				const barrelTip = new THREE.Vector3(0, 0, -0.7);
				const worldPosition = new THREE.Vector3();
				
				// Convertir la position locale en position mondiale
				this.cannonGroup.updateMatrixWorld();
				worldPosition.copy(barrelTip).applyMatrix4(this.cannonGroup.matrixWorld);
				
				// Cr√©er un ID temporaire pour le projectile
				const tempId = `temp-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
				
				// Cr√©er le projectile
				const projectile = new Projectile(this.scene, worldPosition, direction, this, this.collisionSystem);
				projectile.id = tempId; // Assigner l'ID temporaire
				this.projectiles.push(projectile);
				
				return projectile;
			}    
			
            // Effet de recul pour les canons lat√©raux
			showSideCannonRecoilEffect(cannon) {
				// Annuler tout timeout pr√©c√©dent pour ce canon
				if (cannon.recoilTimeout) {
					clearTimeout(cannon.recoilTimeout);
				}
				
				// V√©rifier et mettre √† jour la position de r√©f√©rence si n√©cessaire
				if (!cannon.initialPosition && cannon.barrel) {
					cannon.initialPosition = cannon.barrel.position.clone();
				}
				
				// Toujours revenir √† la position initiale avant d'appliquer un nouveau recul
				cannon.barrel.position.copy(cannon.initialPosition);
				
				// Puis appliquer le recul
				cannon.barrel.position.z += 0.08;
				
				// Enregistrer le timeout pour pouvoir l'annuler si n√©cessaire
				cannon.recoilTimeout = setTimeout(() => {
					cannon.barrel.position.copy(cannon.initialPosition);
					cannon.recoilTimeout = null;
				}, 100);
			}
			
			// Effet de recul lors du tir
			showRecoilEffect() {
				// Annuler tout timeout pr√©c√©dent pour √©viter les chevauchements
				if (this.recoilTimeout) {
					clearTimeout(this.recoilTimeout);
				}
				
				// V√©rifier et mettre √† jour la position de r√©f√©rence si n√©cessaire
				if (!this.cannonBarrelInitialState) {
					this.cannonBarrelInitialState = {
						position: this.cannonBarrel.position.clone()
					};
				}
				
				// Toujours revenir √† la position initiale avant d'appliquer un nouveau recul
				this.cannonBarrel.position.copy(this.cannonBarrelInitialState.position);
				
				// Puis appliquer le recul
				this.cannonBarrel.position.z += 0.1;
				
				// Enregistrer le timeout pour pouvoir l'annuler si n√©cessaire
				this.recoilTimeout = setTimeout(() => {
					this.cannonBarrel.position.copy(this.cannonBarrelInitialState.position);
					this.recoilTimeout = null;
				}, 100);
			}	
			
			resetAllRecoils() {
				// Annuler tout timeout de recul et r√©initialiser le canon principal
				if (this.recoilTimeout) {
					clearTimeout(this.recoilTimeout);
					this.recoilTimeout = null;
				}
				
				if (this.cannonBarrel && this.cannonBarrelInitialState) {
					this.cannonBarrel.position.copy(this.cannonBarrelInitialState.position);
				}
				
				// R√©initialiser tous les canons lat√©raux
				if (this.sideCannons) {
					this.sideCannons.forEach(cannon => {
						if (cannon.recoilTimeout) {
							clearTimeout(cannon.recoilTimeout);
							cannon.recoilTimeout = null;
						}
						
						if (cannon.barrel && cannon.initialPosition) {
							cannon.barrel.position.copy(cannon.initialPosition);
						}
					});
				}
			}

			// Mettre √† jour les projectiles
			updateProjectiles() {
				for (let i = this.projectiles.length - 1; i >= 0; i--) {
					const isActive = this.projectiles[i].update();
					if (!isActive) {
						this.projectiles.splice(i, 1);
					}
				}
			}
			
			// M√©thode pour recevoir des d√©g√¢ts
			takeDamage(amount) {
				if (!this.isAlive) return;
				
				// R√©duire les d√©g√¢ts en fonction de la r√©sistance
				const reductionRatio = 1 - 1/(1 + this.resistance/100);
				const actualDamage = Math.max(1, Math.round(amount * (1 - reductionRatio)));
				
				this.hp -= actualDamage;
				console.log(`Robot touch√©! D√©g√¢ts: ${actualDamage}, HP restants: ${this.hp}`);
				
				// Afficher le texte des d√©g√¢ts
				createDamageText(this.mesh.position, actualDamage);
				
				// Effet visuel de d√©g√¢ts
				this.showDamageEffect();
				
				// Mettre √† jour l'interface utilisateur
				this.updateUI();
				
				// V√©rifier si le joueur est mort
				if (this.hp <= 0) {
					console.log("Le robot est d√©truit!");
					this.hp = 0; // Emp√™cher les HP n√©gatifs
					this.updateUI();
					this.die();
				}
				
				// Si c'est le joueur principal, mettre √† jour le serveur
				if (this.isMainPlayer) {
					socket.emit('playerUpdate', {
						hp: this.hp,
						isAlive: this.isAlive
					});
				}
			}
			
			// M√©thode appel√©e quand le robot est d√©truit
			die() {
				if (!this.isAlive) return; // √âviter de d√©clencher plusieurs fois
				
				this.isAlive = false;
				
				// Marquer le robot comme mort
				console.log("Le robot est d√©truit! Lib√©ration des processeurs...");
				
				// Effet visuel de destruction
				this.showDestructionEffect();
				
				// Retirer le joueur du syst√®me de collision
				if (this.collisionSystem) {
					this.collisionSystem.removeObject(this);
				}
				
				// Suppression du tag de nom
				if (this.nameTag && this.nameTag.parentNode) {
					document.body.removeChild(this.nameTag);
					this.nameTag = null;
				}
				
				// Nettoyer tous les projectiles actifs
				if (this.projectiles) {
					this.projectiles.forEach(p => {
						if (p && p.destroy) p.destroy();
					});
					this.projectiles = [];
				}
				
				// Supprimer compl√®tement le mod√®le 3D de la sc√®ne
				if (this.mesh && this.scene) {
					// Disposer proprement de toutes les ressources
					disposeThreeObject(this.mesh);
					this.scene.remove(this.mesh);
					this.mesh = null;
				}
				
				// Si c'est le joueur principal, afficher l'√©cran de connexion
				if (this.isMainPlayer) {
					// Attendre un court d√©lai pour voir l'explosion
					setTimeout(() => {
						// R√©initialiser le statut du jeu
						gameStarted = false;
						
						// Cr√©er l'√©cran de mort
						createDeathScreen(this.lastKiller);
					}, 2000); // D√©lai de 2 secondes pour voir l'explosion
				}

			}
			
			// Effet visuel lors de la destruction du robot
			showDestructionEffect() {
				// Masquer visuellement le robot (vous pourriez ajouter une animation plus complexe)
				this.mesh.visible = false;
				
				// Cr√©er une explosion √† la position du robot
				const explosionGeometry = new THREE.SphereGeometry(1, 16, 16);
				const explosionMaterial = new THREE.MeshStandardMaterial({ 
					color: 0xff6600,
					emissive: 0xff9900,
					emissiveIntensity: 1,
					transparent: true,
					opacity: 0.9
				});
				
				const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
				explosion.position.copy(this.mesh.position);
				this.scene.add(explosion);
				
				// Faire grandir puis dispara√Ætre l'explosion
				let scale = 0.1;
				const expandExplosion = () => {
					scale += 0.15;
					explosion.scale.set(scale, scale, scale);
					explosionMaterial.opacity -= 0.05;
					
					if (scale < 2) {
						requestAnimationFrame(expandExplosion);
					} else {
						// Nettoyer proprement les ressources
						this.scene.remove(explosion);
						explosionGeometry.dispose();
						explosionMaterial.dispose();
					}
				};
				
				requestAnimationFrame(expandExplosion);
			}
			
			//Conserver les couleurs originales
			storeOriginalColors() {
				// Cr√©er un tableau pour stocker les couleurs originales de chaque partie
				this.originalBodyColors = [];
				this.bodyParts.forEach(part => {
					if (part && part.material && part.material.color) {
						this.originalBodyColors.push(part.material.color.clone());
					} else {
						// Couleur par d√©faut au cas o√π
						this.originalBodyColors.push(new THREE.Color(0x3a7d44));
					}
				});
			}

			// Effet visuel pour les d√©g√¢ts
			showDamageEffect() {
				console.log(`Effet de d√©g√¢ts pour ${this.username}, ID: ${this.playerId}`);
				
				// V√©rifier que nous avons des parties de corps √† colorier
				if (!this.bodyParts || this.bodyParts.length === 0) {
					console.warn("Aucune partie de corps d√©finie pour l'effet de d√©g√¢ts");
					return;
				}
				
				// Stocker les couleurs originales si ce n'est pas d√©j√† fait
				if (!this.originalBodyColors || this.originalBodyColors.length === 0) {
					console.log("Stockage des couleurs originales");
					this.storeOriginalColors();
				}
				
				// Change la couleur du corps du robot pendant un court moment
				this.bodyParts.forEach(part => {
					if (part && part.material) {
						part.material.color.set(0xff0000);  // Rouge quand touch√©
					}
				});
				
				// Revenir aux couleurs d'origine apr√®s un d√©lai
				setTimeout(() => {
					if (!this.originalBodyColors) return; // Protection suppl√©mentaire
					
					this.bodyParts.forEach((part, index) => {
						if (part && part.material && index < this.originalBodyColors.length) {
							part.material.color.copy(this.originalBodyColors[index]);
						}
					});
				}, 200);
			}
			
			// Cr√©er le corps du robot (cadre rectangulaire avec colonnes √† l'int√©rieur)
			createRobotBody() {
				// Groupe pour le corps
				this.bodyGroup = new THREE.Group();
				this.mesh.add(this.bodyGroup);
				
				// Mat√©riaux pour le corps et les cadres
				const bodyMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x3a7d44,  // Vert militaire
					roughness: 0.7,
					metalness: 0.5
				});
				
				const frameMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x294d2f,  // Vert fonc√© pour les bordures
					roughness: 0.6,
					metalness: 0.7
				});
				
				// Dimensions du corps
				const bodyWidth = this.bodyWidth;
				const bodyHeight = this.bodyHeight;
				const bodyDepth = this.bodyDepth;
				const frameThickness = this.frameThickness;
				
				// Cr√©er le cadre rectangulaire vide (en cr√©ant 5 panneaux s√©par√©s)
				
				// Panneau inf√©rieur (plus √©pais)
				const bottomGeometry = new THREE.BoxGeometry(bodyWidth, this.bottomThickness, bodyDepth);
				const bottomPanel = new THREE.Mesh(bottomGeometry, frameMaterial);
				bottomPanel.position.y = 0.215 + (this.bottomThickness - frameThickness)/2; // Ajust√© pour la nouvelle √©paisseur
				bottomPanel.castShadow = true;
				bottomPanel.receiveShadow = true;
				this.bodyGroup.add(bottomPanel);
				
				// Panneau sup√©rieur
				const topGeometry = new THREE.BoxGeometry(bodyWidth, frameThickness, bodyDepth);
				const topPanel = new THREE.Mesh(topGeometry, frameMaterial);
				topPanel.position.y = 0.215 + bodyHeight - frameThickness;
				topPanel.castShadow = true;
				topPanel.receiveShadow = true;
				this.bodyGroup.add(topPanel);
				
				// Panneaux lat√©raux
				const leftGeometry = new THREE.BoxGeometry(frameThickness, bodyHeight, bodyDepth);
				const leftPanel = new THREE.Mesh(leftGeometry, frameMaterial);
				leftPanel.position.x = -bodyWidth/2 + frameThickness/2;
				leftPanel.position.y = 0.215 + bodyHeight/2;
				leftPanel.castShadow = true;
				leftPanel.receiveShadow = true;
				this.bodyGroup.add(leftPanel);
				
				const rightGeometry = new THREE.BoxGeometry(frameThickness, bodyHeight, bodyDepth);
				const rightPanel = new THREE.Mesh(rightGeometry, frameMaterial);
				rightPanel.position.x = bodyWidth/2 - frameThickness/2;
				rightPanel.position.y = 0.215 + bodyHeight/2;
				rightPanel.castShadow = true;
				rightPanel.receiveShadow = true;
				this.bodyGroup.add(rightPanel);
				
				// R√©f√©rence pour les autres m√©thodes
				this.body = this.bodyGroup;
				
				// Ajouter les parties √† bodyParts
				this.bodyParts.push(bottomPanel, topPanel, leftPanel, rightPanel);
				
				// Cr√©er une plaque de base non transparente
				const basePlateGeometry = new THREE.BoxGeometry(bodyWidth - 2*frameThickness, frameThickness/2, bodyDepth - 2*frameThickness);
				const basePlateMaterial = new THREE.MeshStandardMaterial({
					color: 0x555555,
					roughness: 0.5,
					metalness: 0.8
				});
				const basePlate = new THREE.Mesh(basePlateGeometry, basePlateMaterial);
				basePlate.position.y = 0.05 + frameThickness*1.5;
				this.bodyGroup.add(basePlate);
				this.bodyParts.push(basePlate);
				
				// Calculer les positions et dimensions pour les colonnes de processeurs
				// Le bas du conteneur est juste au-dessus du panneau inf√©rieur (sans espacement suppl√©mentaire)
				this.columnBottomY = 0.2 + this.bottomThickness;
				
				// Le haut du conteneur est juste en dessous du panneau sup√©rieur
				this.columnTopY = 0.2 + bodyHeight - frameThickness - 0.02;
				
				// Calculer la hauteur du conteneur
				this.columnHeight = this.columnTopY - this.columnBottomY;
				
				// Position centrale du conteneur (pour le positionnement Three.js qui est bas√© sur le centre)
				this.columnCenterY = this.columnBottomY + this.columnHeight / 2;
				
				// Ajustement suppl√©mentaire pour aligner parfaitement les conteneurs
				this.columnCenterY -= 0.05; // D√©caler l√©g√®rement vers le bas
				
				// Cr√©er les colonnes d'indicateurs de processeurs
				this.createProcessorColumns();
				
				this.storeAllInitialPositions();
			}
			
			// Cr√©er les colonnes d'indicateurs pour les processeurs
			createProcessorColumns() {
				// Garder une r√©f√©rence aux colonnes pour pouvoir les mettre √† jour
				this.processorColumns = {};
				
				// D√©finir les propri√©t√©s et leurs couleurs associ√©es
				const propertyColors = {
					hp: 0x00ff00,           // Vert pour HP
					resistance: 0xffa500,   // Orange pour d√©fense
					attack: 0xff0000,       // Rouge pour attaque
					attackSpeed: 0xffff00,  // Jaune pour cadence
					range: 0x0000ff,        // Bleu pour port√©e
					speed: 0x4b0082,        // Indigo pour vitesse
					repairSpeed: 0x8a2be2   // Violet pour r√©paration
				};
				
				// Cr√©er une colonne pour chaque propri√©t√©
				const columnCount = Object.keys(propertyColors).length;
				const spacing = this.columnWidth * 1.1;
				const totalWidth = spacing * (columnCount - 1);
				const startX = -totalWidth / 2;
				
				let index = 0;
				for (const [prop, color] of Object.entries(propertyColors)) {
					// Cr√©er la colonne de niveau directement
					const columnMaterial = new THREE.MeshStandardMaterial({
						color: color,
						roughness: 0.3,
						metalness: 0.8,
						emissive: color,
						emissiveIntensity: 0.3
					});
					
					// La colonne a la m√™me largeur que pr√©c√©demment mais est positionn√©e directement
					const columnGeometry = new THREE.BoxGeometry(this.columnWidth * 0.8, this.columnHeight, this.columnDepth * 0.8);
					const column = new THREE.Mesh(columnGeometry, columnMaterial);
					
					// Positionner la colonne directement dans le corps
					const xPos = startX + index * spacing;
					column.position.set(xPos, this.columnCenterY, 0);
					
					// Commencer avec une petite hauteur
					column.scale.y = 0.1;
					column.originalY = this.columnCenterY - (this.columnHeight / 2);
					// Ajout direct au corps
					this.bodyGroup.add(column);
					
					// Stocker une r√©f√©rence √† la colonne
					this.processorColumns[prop] = column;
					
					// Ajouter aux parties du corps
					this.bodyParts.push(column);
					
					index++;
				}
			}
			
			// M√©thode pour r√©initialiser les positions des colonnes apr√®s un changement d'√©chelle
			resetProcessorColumnPositions() {
				if (!this.processorColumns) return;
				
				const propertyNames = ['hp', 'resistance', 'attack', 'attackSpeed', 'range', 'speed', 'repairSpeed'];
				
				propertyNames.forEach(prop => {
					const column = this.processorColumns[prop];
					if (column) {
						// Si la position originale a √©t√© stock√©e, l'utiliser
						if (column.originalY !== undefined) {
							// Calculer la nouvelle position Y
							column.position.y = column.originalY + (column.scale.y * this.columnHeight / 2);
						}
					}
				});
			}
			
			// Cr√©er un effet de texte flottant
			createFloatingText(position, text, color) {
				// Convertir la position 3D en position 2D sur l'√©cran
				const vector = position.clone();
				vector.project(camera); // Projeter la position 3D sur l'√©cran 2D
				
				// Convertir les coordonn√©es normalis√©es (-1 √† 1) en coordonn√©es de l'√©cran
				const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
				const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
				
				// Cr√©er l'√©l√©ment de texte
				const textElement = document.createElement('div');
				textElement.className = 'floating-text';
				textElement.textContent = text;
				textElement.style.color = color;
				textElement.style.left = x + 'px';
				textElement.style.top = y + 'px';
				document.body.appendChild(textElement);
				
				// D√©marrer l'animation
				setTimeout(() => {
					textElement.style.opacity = '0';
					textElement.style.transform = 'translateY(-50px)';
				}, 10);
				
				// Supprimer l'√©l√©ment apr√®s l'animation
				setTimeout(() => {
					document.body.removeChild(textElement);
				}, 1000);
			}
			
			// Cr√©er les roues et chenilles
			createTracks() {
				// Groupe pour les chenilles
				this.tracksGroup = new THREE.Group();
				this.mesh.add(this.tracksGroup);
				
				// Mat√©riau pour les chenilles
				const trackMaterial = new THREE.MeshStandardMaterial({
					color: 0x333333,
					roughness: 0.8,
					metalness: 0.4
				});
				
				// Initialiser le tableau des roues vide (mais maintenu pour compatibilit√©)
				this.wheels = [];
				
				// Cr√©er uniquement les chenilles
				this.createTrackBelts(trackMaterial);
			}
			
			// M√©thode pour cr√©er les chenilles
			createTrackBelts(material) {
				// Cr√©er les chenilles gauche et droite
				const trackWidth = 0.15; // Plus larges pour compenser l'absence de roues
				const trackHeight = 0.07; // Plus hautes pour une meilleure visibilit√©
				const trackLength = 0.9; // Longues chenilles
				
				// Groupe pour les segments de chenilles
				this.leftTrackSegments = [];
				this.rightTrackSegments = [];
				
				// Mat√©riau pour les chenilles principales
				const mainTrackMaterial = new THREE.MeshStandardMaterial({
					color: 0x222222,
					roughness: 0.8,
					metalness: 0.5
				});
				
				// Chenille gauche (base)
				const leftTrackGeometry = new THREE.BoxGeometry(trackWidth, trackHeight, trackLength);
				const leftTrack = new THREE.Mesh(leftTrackGeometry, mainTrackMaterial);
				leftTrack.position.set(-0.2, 0.15, 0);
				this.tracksGroup.add(leftTrack);
				this.bodyParts.push(leftTrack);
				
				// Chenille droite (base)
				const rightTrackGeometry = new THREE.BoxGeometry(trackWidth, trackHeight, trackLength);
				const rightTrack = new THREE.Mesh(rightTrackGeometry, mainTrackMaterial);
				rightTrack.position.set(0.2, 0.15, 0);
				this.tracksGroup.add(rightTrack);
				this.bodyParts.push(rightTrack);
				
				// Ajouter des segments articul√©s √† chaque chenille
				const segmentCount = 16; // Plus de segments pour plus de d√©tails
				const segmentWidth = trackWidth * 0.95;
				const segmentHeight = trackHeight * 0.8;
				const segmentDepth = trackLength / segmentCount;
				
				// Fonction pour cr√©er les segments sur une chenille
				const createSegments = (xPos, isLeft) => {
					const segments = [];
					const startZ = -trackLength/2 + segmentDepth/2;
					
					for (let i = 0; i < segmentCount; i++) {
						const segmentGeometry = new THREE.BoxGeometry(segmentWidth, segmentHeight, segmentDepth * 0.85);
						const segment = new THREE.Mesh(segmentGeometry, material);
						segment.position.set(xPos, 0.15, startZ + i * segmentDepth);
						
						// Ajouter des d√©tails sur chaque segment
						const detailGeometry = new THREE.BoxGeometry(segmentWidth * 1.1, segmentHeight * 0.3, segmentDepth * 0.2);
						const detail = new THREE.Mesh(detailGeometry, material);
						detail.position.y = segmentHeight * 0.3;
						segment.add(detail);
						
						// Ajouter des crampons pour une apparence de chenille
						if (i % 2 === 0) { // Alterne les segments avec crampons
							const cramponGeometry = new THREE.BoxGeometry(segmentWidth * 1.2, segmentHeight * 0.5, segmentDepth * 0.4);
							const crampon = new THREE.Mesh(cramponGeometry, mainTrackMaterial);
							crampon.position.y = -segmentHeight * 0.5;
							segment.add(crampon);
							this.bodyParts.push(crampon);
						}
						
						this.tracksGroup.add(segment);
						this.bodyParts.push(segment, detail);
						segments.push(segment);
					}
					
					return segments;
				};
				
				// Cr√©er les segments
				this.leftTrackSegments = createSegments(-0.2, true);
				this.rightTrackSegments = createSegments(0.2, false);
				
				// Ajouter les galets de guidage aux extr√©mit√©s des chenilles
				this.addTrackGuides();
				
				this.storeAllInitialPositions();
			}
			
			// Ajouter les galets de guidage aux extr√©mit√©s des chenilles
			addTrackGuides() {
				const guideMaterial = new THREE.MeshStandardMaterial({
					color: 0x444444,
					roughness: 0.5,
					metalness: 0.7
				});
				
				// Cr√©er les galets de guidage aux extr√©mit√©s des chenilles
				const createGuides = (xPos) => {
					// Guide avant
					const frontGuideGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.16, 12);
					frontGuideGeometry.rotateZ(Math.PI / 2);
					const frontGuide = new THREE.Mesh(frontGuideGeometry, guideMaterial);
					frontGuide.position.set(xPos, 0.15, -0.4);
					this.tracksGroup.add(frontGuide);
					
					// Guide arri√®re
					const rearGuideGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.16, 12);
					rearGuideGeometry.rotateZ(Math.PI / 2);
					const rearGuide = new THREE.Mesh(rearGuideGeometry, guideMaterial);
					rearGuide.position.set(xPos, 0.15, 0.4);
					this.tracksGroup.add(rearGuide);
					
					// Ajouter aux parties du corps
					this.bodyParts.push(frontGuide, rearGuide);
				};
				
				// Cr√©er les galets de guidage pour les deux chenilles
				createGuides(-0.2);
				createGuides(0.2);
			}
			
			// Cr√©er le canon
			createCannon() {
				// Cr√©er la t√™te du robot avec la cam√©ra et le canon
				this.createRobotHead();
				// Stocker la position initiale du canon principal
				this.storeAllInitialPositions();
			}
			
			// Stocker les positions initiales
			storeAllInitialPositions() {
				// STOCKAGE DES POSITIONS DU CORPS ET DE LA T√äTE
				// Corps du robot
				if (this.bodyGroup) {
					this.bodyGroupInitialState = {
						position: this.bodyGroup.position.clone(),
						rotation: this.bodyGroup.rotation.clone()
					};
				}
				
				// T√™te du robot
				if (this.headGroup) {
					this.headGroupInitialState = {
						position: this.headGroup.position.clone(),
						rotation: this.headGroup.rotation.clone()
					};
				}
				
				// STOCKAGE DES POSITIONS DES CANONS
				// Canon principal
				if (this.cannonBarrel) {
					this.cannonBarrelInitialState = {
						position: this.cannonBarrel.position.clone()
					};
				}
				
				// Canons lat√©raux
				if (this.sideCannons) {
					this.sideCannons.forEach(cannon => {
						if (cannon.barrel) {
							cannon.initialPosition = cannon.barrel.position.clone();
						}
					});
				}
				
				// STOCKAGE DES POSITIONS DES CHENILLES
				// Segments de chenilles gauches
				if (this.leftTrackSegments && this.leftTrackSegments.length > 0) {
					this.leftTrackInitialPositions = this.leftTrackSegments.map(segment => 
						segment.position.clone()
					);
				}
				
				// Segments de chenilles droites
				if (this.rightTrackSegments && this.rightTrackSegments.length > 0) {
					this.rightTrackInitialPositions = this.rightTrackSegments.map(segment => 
						segment.position.clone()
					);
				}
			}
			
			// Cr√©er la t√™te du robot
			createRobotHead() {
				// Groupe pour la t√™te qui sera positionn√©e au-dessus du corps
				this.headGroup = new THREE.Group();
				this.headGroup.position.y = 1.3; // Ajust√© pour le nouveau corps plus haut
				this.bodyGroup.add(this.headGroup);
				
				// Mat√©riaux
				const headMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x555555,
					roughness: 0.5,
					metalness: 0.7
				});
				
				const glassMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x88ccff,
					roughness: 0.1,
					metalness: 0.9,
					transparent: true,
					opacity: 0.3,
					emissive: 0x1155aa,
					emissiveIntensity: 0.5
				});
				
				// Base de la t√™te (forme cubique/pav√©)
				const headWidth = 0.4;  // Largeur de la t√™te
				const headDepth = 0.4;  // Profondeur de la t√™te
				const headBaseGeometry = new THREE.BoxGeometry(headWidth, this.headHeight, headDepth);
				this.headBase = new THREE.Mesh(headBaseGeometry, headMaterial);
				this.headBase.castShadow = true;
				this.headBase.receiveShadow = true;
				this.headGroup.add(this.headBase);
				
				// D√¥me sup√©rieur (cam√©ra)
				const domeGeometry = new THREE.SphereGeometry(0.18, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
				this.dome = new THREE.Mesh(domeGeometry, headMaterial);
				this.dome.position.y = 0.08;
				this.dome.castShadow = true;
				this.headBase.add(this.dome);
				
				// "Vitre" de la cam√©ra (lentille)
				const lensGeometry = new THREE.CircleGeometry(0.1, 16);
				this.lens = new THREE.Mesh(lensGeometry, glassMaterial);
				this.lens.position.set(0, 0.05, 0);
				this.lens.rotation.x = -Math.PI / 2;
				this.dome.add(this.lens);
				
				// Groupe pour le canon qui sera orient√© dans la direction du mouvement
				this.cannonGroup = new THREE.Group();
				this.cannonGroup.position.z = 0;
				this.cannonGroup.position.y = 0;
				this.headGroup.add(this.cannonGroup);
				
				// Mat√©riaux pour le canon
				const barrelMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x666666,
					roughness: 0.4,
					metalness: 0.8
				});
				
				const baseMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x444444,
					roughness: 0.6,
					metalness: 0.6
				});
				
				
				// Canon lui-m√™me
				const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 10);
				this.cannonBarrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
				this.cannonBarrel.rotation.x = Math.PI / 2; // Orienter horizontalement
				this.cannonBarrel.position.z = -0.35; // Positionner √† l'avant
				this.cannonBarrel.castShadow = true;
				this.cannonGroup.add(this.cannonBarrel);
				this.cannonBarrelBasePosition = -0.35; // Position initiale du canon
				// Ajouter des d√©tails au canon
				this.addCannonDetails();
				
				// Ajouter aux parties du corps
				this.bodyParts.push(this.headBase, this.dome, this.lens, this.cannonBarrel);
				this.storeAllInitialPositions();
			}
			
			// Ajouter des d√©tails au canon
			addCannonDetails() {
				const detailMaterial = new THREE.MeshStandardMaterial({ 
					color: 0x333333,
					roughness: 0.6,
					metalness: 0.7
				});
				
				// Viseur sur le dessus du canon
				const sightGeometry = new THREE.BoxGeometry(0.03, 0.03, 0.15);
				this.sight = new THREE.Mesh(sightGeometry, detailMaterial);
				this.sight.position.set(0, 0.05, -0.2);
				this.sight.castShadow = true;
				this.cannonGroup.add(this.sight);
				

				// Ajouter aux parties du corps
				this.bodyParts.push(this.sight);
			}
			
			// Reset de la position des chenilles √† la position d'origine
			resetTrackSegmentsToInitialPositions() {
				// R√©initialiser les segments gauches
				if (this.leftTrackSegments && this.leftTrackInitialPositions) {
					this.leftTrackSegments.forEach((segment, index) => {
						if (index < this.leftTrackInitialPositions.length) {
							segment.position.copy(this.leftTrackInitialPositions[index]);
						}
					});
				}
				
				// R√©initialiser les segments droits
				if (this.rightTrackSegments && this.rightTrackInitialPositions) {
					this.rightTrackSegments.forEach((segment, index) => {
						if (index < this.rightTrackInitialPositions.length) {
							segment.position.copy(this.rightTrackInitialPositions[index]);
						}
					});
				}
				// Forcer la position Y du robot √† une valeur fixe tr√®s basse
				this.mesh.position.y = 0.01;
			}
			
			// M√©thode pour mettre √† jour l'interface utilisateur
			updateUI() {
			
				// Ne mettre √† jour l'UI que pour le joueur principal
				if (!this.isMainPlayer) return;
				document.getElementById('hp').textContent = Math.floor(this.hp);
				document.getElementById('maxhp').textContent = Math.floor(this.maxHp);
				document.getElementById('atk').textContent = Math.floor(this.attack);
				document.getElementById('def').textContent = Math.floor(this.resistance);
				document.getElementById('atkspeed').textContent = this.attackSpeed.toFixed(2);
				document.getElementById('range').textContent = Math.floor(this.range);
				document.getElementById('speed').textContent = this.speed.toFixed(3);
				document.getElementById('repair').textContent = this.repairSpeed.toFixed(2);
				document.getElementById('processors').textContent = this.totalProcessors;
				
				// Mettre √† jour les indicateurs visuels des processeurs
				this.updateProcessorIndicators();
			}
			
			// Mettre √† jour les indicateurs visuels des processeurs
			updateProcessorIndicators() {
				// Mettre √† jour le niveau de remplissage de chaque colonne
				const propertyNames = ['hp', 'resistance', 'attack', 'attackSpeed', 'range', 'speed', 'repairSpeed'];
				
				propertyNames.forEach(prop => {
					const column = this.processorColumns[prop];
					if (column) {
						// Calculer le niveau de remplissage (0 √† 1)
						const count = this.processorCounts[prop];
						const fillLevel = Math.min(1, count / 100); // Plein √† 100 processeurs
						
						// Stocker l'√©chelle y actuelle avant de la modifier
						const originalScaleY = column.scale.y;
						
						// Mettre √† jour la hauteur de la colonne
						column.scale.y = 0.1 + fillLevel * 0.9; // Minimum 0.1, maximum 1
						
						// R√©tablir la position y du pivot si n√©cessaire
						if (column.originalY === undefined) {
							column.originalY = this.columnCenterY - (this.columnHeight / 2);
						}
						
						// Ajuster la position Y pour que la colonne grandisse vers le haut √† partir du bas
						// Utiliser la position originale stock√©e comme r√©f√©rence
						column.position.y = column.originalY + (column.scale.y * this.columnHeight / 2);
					}
				});
			}
			
			// Cr√©er un effet de pulsation pour une colonne de processeur
			pulseProcessorColumn(column, type) {
				const originalEmissive = column.material.emissiveIntensity;
				const originalScale = column.scale.clone();
				
				// Animation de pulsation
				let pulseStep = 0;
				const maxSteps = 20;
				
				const doPulse = () => {
					// Calculer l'intensit√© de la pulsation (sinuso√Ødale)
					const pulseIntensity = Math.sin((pulseStep / maxSteps) * Math.PI);
					
					// Mettre √† jour l'√©mission et l'√©chelle
					column.material.emissiveIntensity = originalEmissive + pulseIntensity * 0.7;
					
					// √âchelle l√©g√®rement plus grande sur X et Z
					const scaleMod = 1 + pulseIntensity * 0.2;
					column.scale.x = originalScale.x * scaleMod;
					column.scale.z = originalScale.z * scaleMod;
					
					pulseStep++;
					
					if (pulseStep <= maxSteps) {
						requestAnimationFrame(doPulse);
					} else {
						// Restaurer les valeurs d'origine
						column.material.emissiveIntensity = originalEmissive;
						column.scale.x = originalScale.x;
						column.scale.z = originalScale.z;
					}
				};
				
				doPulse();
			}
			
			// R√©parer automatiquement le robot
			repair(deltaTime) {
				if (!this.isAlive) return;
				
				if (this.hp < this.maxHp) {
					// R√©parer en fonction du temps √©coul√©
					this.hp = Math.min(this.maxHp, this.hp + this.repairSpeed * deltaTime);
					// Mettre √† jour l'interface utilisateur
					this.updateUI();
				}
			}
		}    
		
		// Ajouter cette fonction apr√®s la d√©finition de la classe Player
		function createDeathScreen(killer) {
			// Si killer est undefined, utiliser un message par d√©faut
			const killerName = killer ? killer.username : "un adversaire inconnu";
			
			// Cr√©er l'√©l√©ment principal de l'√©cran de mort
			const deathScreen = document.createElement('div');
			deathScreen.id = 'death-screen';
			deathScreen.style.position = 'absolute';
			deathScreen.style.top = '0';
			deathScreen.style.left = '0';
			deathScreen.style.width = '100%';
			deathScreen.style.height = '100%';
			deathScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
			deathScreen.style.display = 'flex';
			deathScreen.style.flexDirection = 'column';
			deathScreen.style.justifyContent = 'center';
			deathScreen.style.alignItems = 'center';
			deathScreen.style.zIndex = '2000';
			deathScreen.style.fontFamily = 'Arial, sans-serif';
			deathScreen.style.color = 'white';
			
			// Ajouter le message principal
			const messageElement = document.createElement('h1');
			messageElement.textContent = `Vous avez √©t√© tu√© par ${killerName}`;
			messageElement.style.fontSize = '36px';
			messageElement.style.marginBottom = '30px';
			messageElement.style.textAlign = 'center';
			messageElement.style.color = '#ff3333';
			messageElement.style.textShadow = '0 0 10px #ff0000';
			deathScreen.appendChild(messageElement);
			
			// Conteneur pour les statistiques et le bouton
			const contentContainer = document.createElement('div');
			contentContainer.style.display = 'flex';
			contentContainer.style.width = '80%';
			contentContainer.style.maxWidth = '900px';
			contentContainer.style.justifyContent = 'space-between';
			contentContainer.style.alignItems = 'center';
			deathScreen.appendChild(contentContainer);
			
			// Cr√©er le bouton de rejouer
			const replayButton = document.createElement('button');
			replayButton.textContent = 'REJOUER';
			replayButton.style.fontSize = '24px';
			replayButton.style.padding = '15px 40px';
			replayButton.style.backgroundColor = '#4CAF50';
			replayButton.style.color = 'white';
			replayButton.style.border = 'none';
			replayButton.style.borderRadius = '5px';
			replayButton.style.cursor = 'pointer';
			replayButton.style.margin = '0 auto';
			replayButton.style.transition = 'background-color 0.3s';
			
			// Effet de survol
			replayButton.addEventListener('mouseover', () => {
				replayButton.style.backgroundColor = '#45a049';
			});
			replayButton.addEventListener('mouseout', () => {
				replayButton.style.backgroundColor = '#4CAF50';
			});
			
			// Action du bouton: rafra√Æchir la page
			replayButton.addEventListener('click', () => {
				window.location.reload();
			});
			
			contentContainer.appendChild(replayButton);
			
			// Ajouter les statistiques du tueur si elles sont disponibles
			if (killer) {
				const statsContainer = document.createElement('div');
				statsContainer.style.backgroundColor = 'rgba(50, 50, 50, 0.7)';
				statsContainer.style.padding = '20px';
				statsContainer.style.borderRadius = '10px';
				statsContainer.style.minWidth = '250px';
				
				const statsTitle = document.createElement('h3');
				statsTitle.textContent = `Statistiques de ${killer.username}`;
				statsTitle.style.marginTop = '0';
				statsTitle.style.marginBottom = '15px';
				statsTitle.style.textAlign = 'center';
				statsContainer.appendChild(statsTitle);
				
				// Formatter et ajouter chaque statistique
				const stats = [
					{ name: 'HP', value: Math.floor(killer.hp) + '/' + Math.floor(killer.maxHp) },
					{ name: 'D√©fense', value: Math.floor(killer.resistance) },
					{ name: 'Attaque', value: Math.floor(killer.attack) },
					{ name: 'Cadence', value: killer.attackSpeed.toFixed(2) },
					{ name: 'Port√©e', value: Math.floor(killer.range) },
					{ name: 'Vitesse', value: killer.speed.toFixed(3) },
					{ name: 'Processeurs', value: killer.totalProcessors || 0 }
				];
				
				stats.forEach(stat => {
					const statRow = document.createElement('div');
					statRow.style.display = 'flex';
					statRow.style.justifyContent = 'space-between';
					statRow.style.marginBottom = '8px';
					
					const statName = document.createElement('span');
					statName.textContent = stat.name + ':';
					statRow.appendChild(statName);
					
					const statValue = document.createElement('span');
					statValue.textContent = stat.value;
					statValue.style.fontWeight = 'bold';
					statRow.appendChild(statValue);
					
					statsContainer.appendChild(statRow);
				});
				
				contentContainer.appendChild(statsContainer);
			}
			
			// Ajouter l'√©cran √† la page
			document.body.appendChild(deathScreen);
		}
		
		function createServerStructure(structureData) {
			// Cr√©er les structures en fonction de leur type
			switch(structureData.type) {
				case 'waterTower':
					createServerWaterTower(structureData);
					break;
				case 'tree':
					createServerTree(structureData);
					break;
			}
		}

		function createServerWaterTower(structureData) {
			const position = new THREE.Vector3(
				structureData.position.x,
				structureData.position.y,
				structureData.position.z
			);
			
			const waterTower = new WaterTower(scene, position, collisionSystem);
			waterTower.id = structureData.id;
			
			// Ajouter √† la liste des structures de la carte
			gameMap.structures.push(waterTower);
		}

		function createServerTree(structureData) {
			const position = new THREE.Vector3(
				structureData.position.x,
				structureData.position.y,
				structureData.position.z
			);
			
			const tree = new Tree(scene, position, collisionSystem);
			tree.id = structureData.id;
			
			// Mettre √† jour les points de vie si fournis
			if (structureData.hp !== undefined) {
				tree.hp = structureData.hp;
				tree.maxHp = structureData.maxHp || tree.maxHp;
			}
			
			// Marquer comme d√©truit si n√©cessaire
			if (structureData.destroyed) {
			  tree.isAlive = false;
			  tree.destroy(); // Appeler directement destroy() plut√¥t que die()
			}
			
			// Ajouter aux listes
			gameMap.trees.push(tree);
			gameMap.structures.push(tree);
		}
		
		// Configuration de la sc√®ne
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);  // Ciel bleu
        const camera = new THREE.PerspectiveCamera(15, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Ajout d'une lumi√®re ambiante
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Ajout d'une lumi√®re directionnelle principale (soleil)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 70, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);
        
        // Activer les ombres dans le rendu
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Ombres plus douces

        // Initialisation du syst√®me de collision
        const collisionSystem = new CollisionSystem();

        // Initialisation de la carte
        const gameMap = new GameMap(scene, collisionSystem);

        // Initialisation du robot du joueur
		let player = null; // Initialiser √† null

        // Initialisation du contr√¥leur de cam√©ra
        let cameraController = null;

        // Positionnement et configuration de la cam√©ra
        camera.position.set(0, 100, 0); // Position la cam√©ra en hauteur et en retrait
        camera.lookAt(0,0,0); // Oriente la cam√©ra vers le joueur

        // Gestion des touches
        const keys = { 
            ArrowUp: false, 
            ArrowDown: false, 
            ArrowLeft: false, 
            ArrowRight: false, 
            Control: false 
        };

        document.addEventListener('keydown', (event) => {
            if (event.key in keys) {
                keys[event.key] = true;
                event.preventDefault(); // Emp√™cher le d√©filement de la page avec les fl√®ches
            }
        });

        document.addEventListener('keyup', (event) => {
            if (event.key in keys) keys[event.key] = false;
        });

		const loginScreen = document.getElementById('login-screen');
		const usernameInput = document.getElementById('username-input');
		const joinButton = document.getElementById('join-button');

		// √âtat du jeu
		let gameStarted = false;

		// √âcouteur d'√©v√©nement pour le bouton de connexion
		joinButton.addEventListener('click', joinGame);

		// Permettre la validation avec la touche Entr√©e
		usernameInput.addEventListener('keypress', (e) => {
			if (e.key === 'Enter') joinGame();
		});

		// Fonction pour rejoindre la partie
		function joinGame() {
			// R√©cup√©rer le nom d'utilisateur
			if (usernameInput.value.trim() !== '') {
				username = usernameInput.value.trim();
			}
			
			// Masquer l'√©cran de connexion
			loginScreen.style.display = 'none';
			
		    // Cr√©er le joueur seulement maintenant
			player = new Player(scene, gameMap, collisionSystem);
			player.username = username;
			
			// Initialiser le contr√¥leur de cam√©ra apr√®s la cr√©ation du joueur
			cameraController = new CameraController(player);
			
			// Marquer le jeu comme d√©marr√©
			gameStarted = true;
			
			// Si le joueur √©tait mort ou n'existe pas, le recr√©er
			if (!player || !player.mesh || !player.isAlive) {
				// Stocker le nom d'utilisateur si le joueur existait d√©j√†
				const previousUsername = player ? player.username : username;
				
				// Cr√©er un nouveau joueur
				player = new Player(scene, gameMap, collisionSystem);
				player.username = previousUsername || username;
				
				// R√©initialiser la cam√©ra pour le nouveau joueur
				cameraController = new CameraController(player);
			} else {
				// Mettre √† jour le nom d'utilisateur
				player.username = username;
			}
			
			// V√©rifier si la connexion socket est d√©j√† √©tablie
			if (socket.connected) {
				console.log("Connexion d√©j√† √©tablie. D√©marrage du jeu...");
				startGame();
			} else {
				console.log("En attente de la connexion au serveur...");
				// Attendre la connexion avant de d√©marrer le jeu
				socket.on('connect', () => {
					console.log("Connexion √©tablie. D√©marrage du jeu...");
					startGame();
				});
			}
		}
       
	   // Fonction pour mettre √† jour la cam√©ra
		function updateCamera() {
			// Only update camera if player exists
			if (player && player.mesh) {
				cameraController.updateCamera(camera);
			} else {
				// Default camera position when no player exists
				camera.position.set(0, 100, 0);
				camera.lookAt(0, 0, 0); // Look at the center of the map
			}
		}

        // Stockage des autres joueurs
		const otherPlayers = {};

		// G√©rer les √©v√©nements de socket.io pour le cycle de jeu
		function setupSocketListeners() {
		
		    if (listenersInitialized) return;
			
			listenersInitialized = true;
			
			// Recevoir l'√©tat initial du jeu
			socket.on('gameState', (state) => {
				console.log('√âtat initial du jeu re√ßu:', state);
				
				// Traiter les structures statiques
				if (state.structures) {
					console.log(`Structures re√ßues: ${Object.keys(state.structures).length}`);
					// IMPORTANT : Vider les structures existantes avant d'en cr√©er de nouvelles
					gameMap.structures.forEach(structure => {
					  if (structure.destroy) structure.destroy();
					});
					gameMap.structures = [];
					
					Object.values(state.structures).forEach(structureData => {
						console.log(`Cr√©ation de la structure ${structureData.id} de type ${structureData.type}`);
						createServerStructure(structureData);
					});
				} else {
					console.warn("Aucune structure re√ßue du serveur!");
				}
				
				// Traiter les joueurs existants
				Object.entries(state.players).forEach(([id, playerData]) => {
					if (id !== socket.id && !otherPlayers[id] && playerData.isAlive) {
					createOtherPlayer(id, playerData);
					}
				});
				
				// Traiter les processeurs existants
				Object.values(state.processors).forEach(processorData => {
					createServerProcessor(processorData);
				});
				
				// Traiter les canons existants
				Object.values(state.cannons).forEach(cannonData => {
					createServerCannon(cannonData);
				});
				
				// Afficher l'horloge si nous recevons aussi des informations sur la partie
				if (state.gameInfo) {
					showGameClock(state.gameInfo.endTime);
				}
			});
            
            // Gestion des √©v√©nements de cycle de jeu
            socket.on('gameEnded', (data) => {
                console.log('La partie est termin√©e!', data);
                
                // Afficher le podium
                showPodium(data.winners);
                
                // D√©marrer le compte √† rebours pour le red√©marrage
                startCountdown(data.duration / 1000, 'Restarting in');
            });

            socket.on('gameRestarting', (data) => {
                console.log('Red√©marrage imminent...');
                
                // Avertir le joueur du red√©marrage imminent
                showRestartingMessage();
                
                // D√©marrer un compte √† rebours court
                startCountdown(data.duration / 1000, 'Red√©marrage dans');
            });

			socket.on('gameRestarted', (data) => {
			  console.log('Nouvelle partie! Rafra√Æchissement de la page...');
			  
			  // D√©lai court pour permettre au message de s'afficher dans la console
			  setTimeout(() => {
				window.location.reload();
			  }, 100);
			});

			// Un nouveau joueur rejoint
			socket.on('playerJoined', (playerData) => {
				console.log('Nouveau joueur rejoint:', playerData);
				createOtherPlayer(playerData.id, playerData);
				updateScoreboard();
			});
			
			// Recevoir la liste compl√®te des joueurs
			socket.on('playerList', (players) => {
				Object.entries(players).forEach(([id, playerData]) => {
					if (id !== socket.id && !otherPlayers[id]) {
						createOtherPlayer(id, playerData);
					}
				});
				updateScoreboard();
			});
			
			// Un joueur se d√©place
			socket.on('playerMoved', (playerData) => {
				if (otherPlayers[playerData.id]) {
					updateOtherPlayerPosition(playerData.id, playerData);
				}
			});
				
			// Un projectile est cr√©√© par le serveur
			socket.on('projectileCreated', (projectileData) => {
				if (projectileData.ownerId !== socket.id) {
					// C'est un projectile d'un autre joueur
					createServerProjectile(projectileData);
				} else {
					// C'est notre propre projectile, mettre √† jour l'ID
					// Chercher le projectile temporaire correspondant √† la position
					const position = new THREE.Vector3(
						projectileData.position.x,
						projectileData.position.y,
						projectileData.position.z
					);
					
					// Trouver le projectile local qui correspond le mieux
					let closestProjectile = null;
					let minDistance = Infinity;
					
					for (const p of player.projectiles) {
						if (p.id && p.id.startsWith('temp-')) {
							const dist = p.group.position.distanceTo(position);
							if (dist < minDistance) {
								minDistance = dist;
								closestProjectile = p;
							}
						}
					}
					
					// Mettre √† jour l'ID si on a trouv√© un projectile correspondant
					if (closestProjectile && minDistance < 1.0) {
						console.log(`Mise √† jour du projectile: ${closestProjectile.id} -> ${projectileData.id}`);
						closestProjectile.id = projectileData.id;
					}
				}
			});
			
			// Un joueur est touch√©
			socket.on('playerDamaged', (data) => {
				console.log("√âv√©nement playerDamaged re√ßu:", data);
				
				if (data.id === socket.id) {
					// C'est nous qui sommes touch√©s, mais nous g√©rons nos propres d√©g√¢ts
					// Uniquement synchroniser en cas de diff√©rence importante
					if (Math.abs(player.hp - data.hp) > 5) {
						player.hp = data.hp;
						player.updateUI();
					}
					// V√©rifier que notre mesh existe avant de cr√©er l'effet visuel
					if (player.mesh && player.isAlive) {
						createDamageText(player.mesh.position, data.damage);
						player.showDamageEffect();
					}
					
				} else if (otherPlayers[data.id]) {
					console.log("Joueur touch√© trouv√©:", otherPlayers[data.id].username);
					// Un autre joueur est touch√©
					otherPlayers[data.id].hp = data.hp;
					
					// Add null check for mesh and position
					if (otherPlayers[data.id].mesh && otherPlayers[data.id].mesh.position) {
						createDamageText(otherPlayers[data.id].mesh.position, data.damage);
					}
					
					// S'assurer que les couleurs originales sont stock√©es
					if (!otherPlayers[data.id].originalBodyColors || 
						otherPlayers[data.id].originalBodyColors.length === 0) {
						otherPlayers[data.id].storeOriginalColors();
					}
					
					// Appliquer l'effet visuel
					otherPlayers[data.id].showDamageEffect();
				} else {
					console.log("Joueur touch√© non trouv√© dans la liste:", data.id);
				}
			});
			
			// Un joueur est tu√©
			socket.on('playerKilled', (data) => {
			  if (data.id === socket.id) {
				// Stocker le tueur
				if (data.killerId && otherPlayers[data.killerId]) {
				  player.lastKiller = otherPlayers[data.killerId];
				}
				// Nous sommes morts (devrait d√©j√† √™tre g√©r√© localement)
				if (player.isAlive) {
				  player.die();
				}
			  } else if (otherPlayers[data.id]) {
				// Un autre joueur est mort
				otherPlayers[data.id].die();
			  }
			  // Mise √† jour du tableau des scores imm√©diatement apr√®s une √©limination
			  updateScoreboard();
			  
			  // Demander au serveur une mise √† jour des processeurs
			  // Cela garantit que tous les processeurs largu√©s sont synchronis√©s
			  socket.emit('requestProcessorsUpdate');
			});
			
			// Mise √† jour des processeurs existants
			socket.on('processorsUpdate', (processors) => {
			  // Supprimer les processeurs existants qui ne sont plus dans la liste du serveur
			  gameMap.processors.forEach(processor => {
				if (!processors[processor.id]) {
				  processor.destroy();
				  gameMap.removeProcessor(processor);
				}
			  });
			  
			  // Ajouter les nouveaux processeurs
			  Object.values(processors).forEach(processorData => {
				if (!gameMap.processors.some(p => p.id === processorData.id)) {
				  createServerProcessor(processorData);
				}
			  });
			});
			
			// Un joueur quitte
			socket.on('playerLeft', (playerId) => {
				if (otherPlayers[playerId]) {
					removeOtherPlayer(playerId);
					updateScoreboard();
				}
			});
			
			// Un nouveau processeur est cr√©√©
			socket.on('processorCreated', (processorData) => {
				createServerProcessor(processorData);
			});
			
			// Un processeur est supprim√©
			socket.on('processorRemoved', (data) => {
				removeServerProcessor(data.id);
			});
			
			// Un nouveau canon est cr√©√©
			socket.on('cannonCreated', (cannonData) => {
				createServerCannon(cannonData);
			});
			
			// Un canon est supprim√©
			socket.on('cannonRemoved', (data) => {
				removeServerCannon(data.id);
			});
			
			// Mise √† jour des statistiques d'un joueur
			socket.on('playerStatsUpdated', (data) => {
			  if (data.id === socket.id) {
				// Synchroniser nos statistiques si n√©cessaire
				// Inclure totalProcessors qui est important pour le leaderboard
				if (data.totalProcessors) {
				  player.totalProcessors = data.totalProcessors;
				}
				player.updateUI();
			  } else if (otherPlayers[data.id]) {
				// Mettre √† jour les statistiques d'un autre joueur
				updateOtherPlayerStats(data.id, data);
			  }
			  // Mettre √† jour le tableau des scores apr√®s chaque mise √† jour de statistiques
			  updateScoreboard();
			});
			
			// Ajouter des gestionnaires pour les d√©g√¢ts aux structures
			socket.on('structureDamaged', (data) => {
				// Trouver la structure dans la liste
				const structure = gameMap.structures.find(s => s.id === data.id);
				if (structure && structure.takeDamage) {
					structure.hp = data.hp;
					structure.showDamageEffect();
					createDamageText(structure.mesh.position, data.damage);
				}
			});
			
			socket.on('structureDestroyed', (data) => {
				// Trouver la structure dans la liste
				const structure = gameMap.structures.find(s => s.id === data.id);
				if (structure && structure.die) {
					structure.die();
				}
			});
			
			// Rafra√Æchissement forc√© au moment des relances du serveur
			socket.on('forceRefresh', (data) => {
			  console.log('Rafra√Æchissement forc√© par le serveur:', data.reason);
			  
			  // Afficher un message bref √† l'utilisateur
			  const message = document.createElement('div');
			  message.style.position = 'fixed';
			  message.style.top = '50%';
			  message.style.left = '50%';
			  message.style.transform = 'translate(-50%, -50%)';
			  message.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
			  message.style.color = 'white';
			  message.style.padding = '20px';
			  message.style.borderRadius = '5px';
			  message.style.zIndex = '9999';
			  message.textContent = 'Nouvelle partie! Rechargement...';
			  document.body.appendChild(message);
			  
			  // Forcer le rafra√Æchissement apr√®s un court d√©lai
			  setTimeout(() => {
				window.location.reload(true); // Le param√®tre true force un rechargement depuis le serveur
			  }, 500);
			});
			
			socket.on('createBotCollider', (data) => {
			  console.log('Cr√©ation du collider pour le bot:', data.botId);
			  
			  // V√©rifier si ce bot existe d√©j√† dans les autres joueurs
			  if (otherPlayers[data.botId]) {
				console.log('Bot d√©j√† existant, mise √† jour du collider');
				
				// MODIFI√â: Forcer la cr√©ation/mise √† jour du collider, peu importe hasCollision
				// Cr√©er le collider sans v√©rification
				otherPlayers[data.botId].createCollider();
				otherPlayers[data.botId].hasCollision = true;

				// Rendre le collider visible
				if (otherPlayers[data.botId].colliderMesh) {
				  otherPlayers[data.botId].colliderMesh.material.opacity = 0.3;
				  otherPlayers[data.botId].colliderMesh.material.color.set(0x00ff00); // Vert
				  console.log('Collider rendu visible pour:', data.botId);
				} else {
				  console.log('colliderMesh non trouv√© pour le bot:', data.botId);
				}

				// Ajouter au syst√®me de collision
				if (collisionSystem) {
				  collisionSystem.addObject(otherPlayers[data.botId]);
				}
			  } else {
				// Cr√©er un joueur pour le bot avec un collider
				const botPlayer = new Player(scene, gameMap, collisionSystem, data.botId, false);
				botPlayer.username = data.username;
				botPlayer.mesh.position.copy(data.position);
				botPlayer.mesh.rotation.y = data.rotation;
				
				// S'assurer que le collider est cr√©√©
				botPlayer.createCollider();
				botPlayer.hasCollision = true;
				
				// AJOUT: Rendre le collider visible imm√©diatement
				if (botPlayer.colliderMesh) {
				  botPlayer.colliderMesh.material.opacity = 0.5; // Plus visible pour le test
				  botPlayer.colliderMesh.material.color.set(0x00ff00); // Vert
				  console.log('Collider cr√©√© et rendu visible pour le nouveau bot:', data.botId);
				} else {
				  console.log('colliderMesh non trouv√© pour le nouveau bot:', data.botId);
				}
				
				// Ajouter au syst√®me de collision
				if (collisionSystem) {
				  collisionSystem.addObject(botPlayer);
				}
				
				// Stocker dans otherPlayers
				otherPlayers[data.botId] = botPlayer;
				
				// Ajouter le tag de nom
				addPlayerNameTag(botPlayer);
				
				console.log(`Bot ${data.botId} ajout√© en tant que joueur avec collider`);
			  }
			});
		
		}
		
		// Fonction pour nettoyer tous les objets du jeu
		function cleanupGameObjects() {
		  // Supprimer tous les processeurs
		  gameMap.processors.forEach(processor => {
			processor.destroy();
		  });
		  gameMap.processors = [];
		  
		  // Supprimer tous les canons
		  gameMap.cannons.forEach(cannon => {
			cannon.destroy();
		  });
		  gameMap.cannons = [];
		  
		  // Supprimer tous les projectiles
		  if (player) {
			player.projectiles.forEach(projectile => {
			  projectile.destroy();
			});
			player.projectiles = [];
		  }
		  
		  // Supprimer les projectiles des autres joueurs
		  Object.values(otherPlayers).forEach(otherPlayer => {
			otherPlayer.projectiles.forEach(projectile => {
			  projectile.destroy();
			});
			otherPlayer.projectiles = [];
		  });
		}
		

		function startGame() {
			// Marquer le jeu comme d√©marr√©
			gameStarted = true;
			
			// V√©rifier que le joueur existe, est vivant et a un mesh
			if (!player || !player.mesh || !player.isAlive) {
				console.log("Recr√©ation du joueur...");
				player = new Player(scene, gameMap, collisionSystem);
				player.username = username;
				cameraController = new CameraController(player);
			}
			
			// Maintenant que nous sommes s√ªrs que le joueur existe, informer le serveur
			console.log("Envoi des informations du joueur au serveur...");
			socket.emit('playerJoin', {
				position: {
					x: player.mesh.position.x,
					y: player.mesh.position.y,
					z: player.mesh.position.z
				},
				rotation: player.mesh.rotation.y,
				direction: {
					x: player.direction.x,
					y: player.direction.y,
					z: player.direction.z
				},
				stats: {
					resistance: player.resistance,
					attack: player.attack,
					attackSpeed: player.attackSpeed,
					range: player.range,
					speed: player.speed,
					repairSpeed: player.repairSpeed,
					processorCounts: player.processorCounts
				},
				hp: player.hp,
				maxHp: player.maxHp,
				username: player.username
			});
			
			// Demander l'√©tat complet du jeu apr√®s avoir rejoint
			socket.emit('requestGameState');
			
			// Ajouter un tag de nom au joueur principal
			addPlayerNameTag(player);
			
			// Mettre √† jour le tableau de score
			updateScoreboard();
			
			// Cr√©er l'interface pour le cycle de jeu
			createGameCycleUI();
		}
		
		// Fonction pour mettre √† jour le tableau de score
		function updateScoreboard() {
			const playersList = document.getElementById('players-list');
			playersList.innerHTML = '';
			
			// Trier les joueurs par score (processeurs collect√©s)
			const sortedPlayers = Object.values(otherPlayers).concat(player)
				.filter(p => p.isAlive !== false)
				.sort((a, b) => (b.totalProcessors || 0) - (a.totalProcessors || 0));
			
			// Ne prendre que les 10 premiers joueurs
			const top10Players = sortedPlayers.slice(0, 10);
			
			top10Players.forEach((p, index) => {
				const isCurrentPlayer = p === player;
				const playerDiv = document.createElement('div');
				playerDiv.style.padding = '5px';
				playerDiv.style.marginBottom = '5px';
				playerDiv.style.borderRadius = '3px';
				playerDiv.style.backgroundColor = isCurrentPlayer ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 255, 255, 0.1)';
				playerDiv.style.display = 'flex';
				playerDiv.style.justifyContent = 'space-between';
				
				// Ajouter le rang dans l'affichage (index + 1 car les indices commencent √† 0)
				playerDiv.innerHTML = `
					<span><strong>#${index + 1}</strong> ${p.username || 'Joueur inconnu'}</span>
					<span>${p.totalProcessors || 0} procs</span>
				`;
				
				playersList.appendChild(playerDiv);
			});
		}

		// Fonction pour cr√©er un autre joueur
		function createOtherPlayer(id, playerData) {
			// Cr√©er un nouveau joueur avec le mode "autre joueur"
			const otherPlayer = new Player(scene, gameMap, collisionSystem, id, false);
			
			// Utiliser les donn√©es re√ßues
			otherPlayer.mesh.position.copy(playerData.position);
			otherPlayer.mesh.rotation.y = playerData.rotation;
			otherPlayer.direction.copy(playerData.direction);
			otherPlayer.hp = playerData.hp;
			otherPlayer.maxHp = playerData.maxHp;
			otherPlayer.isAlive = playerData.isAlive;
			otherPlayer.username = playerData.username;
			
			// Mettre √† jour les statistiques si pr√©sentes
			if (playerData.stats) {
				otherPlayer.resistance = playerData.stats.resistance;
				otherPlayer.attack = playerData.stats.attack;
				otherPlayer.attackSpeed = playerData.stats.attackSpeed;
				otherPlayer.range = playerData.stats.range;
				otherPlayer.speed = playerData.stats.speed;
				otherPlayer.repairSpeed = playerData.stats.repairSpeed;
				
				if (playerData.stats.processorCounts) {
					otherPlayer.processorCounts = playerData.stats.processorCounts;
					otherPlayer.totalProcessors = 0;
					Object.values(otherPlayer.processorCounts).forEach(count => {
						otherPlayer.totalProcessors += count;
					});
				}
			}
			if (otherPlayer.cannonGroup) {
				otherPlayer.cannonGroup.position.y += 0; // Ajuster uniquement le canon
			}
			// Stocker la r√©f√©rence
			otherPlayers[id] = otherPlayer;
			
			// Ajouter le nom au-dessus du joueur
			addPlayerNameTag(otherPlayer);
			
			return otherPlayer;
		}

		// Fonction pour mettre √† jour la position d'un autre joueur
		function updateOtherPlayerPosition(id, playerData) {
			const otherPlayer = otherPlayers[id];
			if (!otherPlayer || !otherPlayer.mesh || !otherPlayer.isAlive) return;
			
			// Mettre √† jour la position et la rotation
			otherPlayer.mesh.position.set(
				playerData.position.x,
				playerData.position.y,
				playerData.position.z
			);
			otherPlayer.mesh.rotation.y = playerData.rotation;
			otherPlayer.direction.copy(playerData.direction);
			
			// Mettre √† jour l'√©tat vivant/mort
			if (playerData.isAlive !== undefined) {
				otherPlayer.isAlive = playerData.isAlive;
			}
			
			// Mettre √† jour le tag de nom
			updatePlayerNameTag(otherPlayer);
		}

		// Fonction pour mettre √† jour les statistiques d'un autre joueur
		function updateOtherPlayerStats(id, data) {
			const otherPlayer = otherPlayers[id];
			if (!otherPlayer) return;
			
			// Mettre √† jour les points de vie
			otherPlayer.hp = data.hp;
			otherPlayer.maxHp = data.maxHp;
			
			// Mettre √† jour les autres statistiques si pr√©sentes
			if (data.stats) {
				otherPlayer.resistance = data.stats.resistance;
				otherPlayer.attack = data.stats.attack;
				otherPlayer.attackSpeed = data.stats.attackSpeed;
				otherPlayer.range = data.stats.range;
				otherPlayer.speed = data.stats.speed;
				otherPlayer.repairSpeed = data.stats.repairSpeed;
				
				if (data.stats.processorCounts) {
					otherPlayer.processorCounts = data.stats.processorCounts;
					otherPlayer.totalProcessors = 0;
					Object.values(otherPlayer.processorCounts).forEach(count => {
						otherPlayer.totalProcessors += count;
					});
				}
				// Mettre √† jour l'√©chelle du joueur en fonction du nombre total de processeurs
				if (otherPlayer.totalProcessors > 0) {
					// Calculer l'√©chelle (m√™me logique que dans la m√©thode collectProcessor)
					otherPlayer.baseScale = 1.0 + (otherPlayer.totalProcessors * 0.005);
					// Appliquer l'√©chelle
					otherPlayer.mesh.scale.set(otherPlayer.baseScale, otherPlayer.baseScale, otherPlayer.baseScale);
				}
			}
		}

		// Fonction pour supprimer un autre joueur
		function removeOtherPlayer(id) {
			if (otherPlayers[id]) {
				const player = otherPlayers[id];
				
				// Supprimer le tag de nom
				removePlayerNameTag(player);
				
				// Nettoyer tous les projectiles
				if (player.projectiles && player.projectiles.length > 0) {
					player.projectiles.forEach(p => {
						if (p && p.destroy) p.destroy();
					});
					player.projectiles = [];
				}
				
				// Supprimer du syst√®me de collision
				if (player.collisionSystem) {
					player.collisionSystem.removeObject(player);
				}
				
				// Disposer proprement de toutes les ressources Three.js
				if (player.mesh) {
					disposeThreeObject(player.mesh);
					scene.remove(player.mesh);
					player.mesh = null;
				}
				
				// Supprimer de la liste des joueurs
				delete otherPlayers[id];
				
				console.log(`Joueur ${id} compl√®tement supprim√© de la sc√®ne`);
			}
		}

		// Fonction pour ajouter un tag de nom au-dessus d'un joueur
		function addPlayerNameTag(player) {
			// Cr√©er un √©l√©ment de texte HTML
			const nameTag = document.createElement('div');
			nameTag.className = 'player-name-tag';
			nameTag.style.position = 'absolute';
			nameTag.style.color = 'white';
			nameTag.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
			nameTag.style.padding = '2px 5px';
			nameTag.style.borderRadius = '3px';
			nameTag.style.fontSize = '12px';
			nameTag.style.pointerEvents = 'none';
			nameTag.style.textAlign = 'center';
			nameTag.style.whiteSpace = 'nowrap';
			nameTag.style.transform = 'translate(-50%, 0)'; // Centrage sans offsetWidth
			nameTag.textContent = player.username || 'Joueur';
			document.body.appendChild(nameTag);
			
			// Stocker la r√©f√©rence sur le joueur
			player.nameTag = nameTag;
			
			// Mettre √† jour initialement
			updatePlayerNameTag(player);
		}

		// Fonction pour mettre √† jour la position du tag de nom
		function updatePlayerNameTag(player) {
			if (!player || !player.nameTag || !player.isAlive || !player.mesh) return;
			
			// Calculer la position 2D √† partir de la position 3D
			const vector = new THREE.Vector3();
			vector.setFromMatrixPosition(player.mesh.matrixWorld);
			vector.y += 2 * player.baseScale; // Positionner au-dessus du joueur (√©chelle adaptative)
			
			// V√©rifier si le joueur est dans le champ de vision de la cam√©ra
			const tempVector = vector.clone();
			tempVector.project(camera);
			
			// Si le joueur est hors du champ de vision ou trop loin de la cam√©ra
			if (Math.abs(tempVector.x) > 1.1 || Math.abs(tempVector.y) > 1.1 || 
				tempVector.z > 1.1 || calculateDistanceToCamera(player.mesh.position) > 150) {
				player.nameTag.style.display = 'none';
				return;
			} else {
				player.nameTag.style.display = 'block';
			}
			
			// Tenir compte du mode de cam√©ra actuel pour ajuster la position
			if (cameraController && cameraController.mode === 'firstPerson' && player === cameraController.player) {
				// Masquer le tag du joueur principal en mode premi√®re personne
				player.nameTag.style.display = 'none';
				return;
			}
			
			vector.project(camera);
			
			// Convertir en coordonn√©es CSS
			const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
			const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
			
			// Adapter le d√©calage vertical √† l'√©chelle du joueur
			const verticalOffset = 30 * Math.max(1, player.baseScale);
			
			// Mettre √† jour le style sans utiliser offsetWidth (probl√®me 6)
			player.nameTag.style.transform = `translate(-50%, 0)`;
			player.nameTag.style.left = `${x}px`;
			player.nameTag.style.top = `${y - verticalOffset}px`;
			
			// Ajouter une barre de vie
			const hpPercent = (player.hp / player.maxHp) * 100;
			
			// D√©terminer la couleur en fonction du pourcentage de vie
			let hpColor;
			if (hpPercent > 75) hpColor = '#00ff00'; // Vert
			else if (hpPercent > 50) hpColor = '#ffff00'; // Jaune
			else if (hpPercent > 25) hpColor = '#ff9900'; // Orange
			else hpColor = '#ff0000'; // Rouge
			
			player.nameTag.innerHTML = `
				${player.username || 'Joueur'}
				<div style="width: 50px; height: 5px; background-color: #333; margin-top: 2px; border-radius: 2px;">
					<div style="width: ${hpPercent}%; height: 100%; background-color: ${hpColor}; border-radius: 2px;"></div>
				</div>
			`;
		}

		// Fonction pour calculer la distance √† la cam√©ra
		function calculateDistanceToCamera(position) {
			return camera.position.distanceTo(position);
		}

		// Fonction pour supprimer le tag de nom
		function removePlayerNameTag(player) {
			if (player.nameTag) {
				if (player.nameTag.parentNode) {
					document.body.removeChild(player.nameTag);
				}
				player.nameTag = null;
			}
		}

		// Fonction pour cr√©er un processeur venant du serveur
		function createServerProcessor(processorData) {
		    // V√©rifier si un processeur avec cet ID existe d√©j√†
			if (gameMap.processors.some(p => p.id === processorData.id)) {
				console.log(`Processeur ${processorData.id} d√©j√† existant, ignor√©`);
				return;
			}
			const position = new THREE.Vector3(
				processorData.position.x,
				processorData.position.y,
				processorData.position.z
			);
			
			const processor = new Processor(scene, position, processorData.type, collisionSystem);
			processor.id = processorData.id;
			processor.boost = processorData.boost;
			
			// Ajouter √† la liste des processeurs de la carte
			gameMap.processors.push(processor);
		}

		// Fonction pour supprimer un processeur
		function removeServerProcessor(id) {
			// Trouver le processeur dans la liste
			const processorIndex = gameMap.processors.findIndex(p => p.id === id);
			if (processorIndex !== -1) {
				const processor = gameMap.processors[processorIndex];
				processor.destroy();
				gameMap.processors.splice(processorIndex, 1);
			}
		}

		// Fonction pour cr√©er un canon venant du serveur
		function createServerCannon(cannonData) {
		    // V√©rifier si un canon avec cet ID existe d√©j√†
			if (gameMap.cannons.some(c => c.id === cannonData.id)) {
				console.log(`Canon ${cannonData.id} d√©j√† existant, ignor√©`);
				return;
			}
			const position = new THREE.Vector3(
				cannonData.position.x,
				cannonData.position.y,
				cannonData.position.z
			);
			
			const cannon = new Cannon(scene, position, collisionSystem);
			cannon.id = cannonData.id;
			
			// Ajouter √† la liste des canons de la carte
			gameMap.cannons.push(cannon);
		}
		
		// Fonction pour supprimer un canon
		function removeServerCannon(id) {
			// Trouver le canon dans la liste
			const cannonIndex = gameMap.cannons.findIndex(c => c.id === id);
			if (cannonIndex !== -1) {
				const cannon = gameMap.cannons[cannonIndex];
				cannon.destroy();
				gameMap.cannons.splice(cannonIndex, 1);
			}
		}

		// Fonction pour cr√©er un projectile venant du serveur
		function createServerProjectile(projectileData) {
			// Trouver le joueur propri√©taire
			let owner;
			if (projectileData.ownerId === socket.id) {
				owner = player;
			} else if (otherPlayers[projectileData.ownerId]) {
				owner = otherPlayers[projectileData.ownerId];
			} else {
				// Si le propri√©taire n'est pas trouv√©, cr√©er un propri√©taire temporaire
				// avec seulement les propri√©t√©s n√©cessaires
				owner = {
					attack: projectileData.damage || 10,
					range: projectileData.maxDistance || 10,
					projectiles: []  // Tableau vide pour √©viter les erreurs
				};
			}
			
			// Cr√©er le projectile
			const position = new THREE.Vector3(
				projectileData.position.x,
				projectileData.position.y,
				projectileData.position.z
			);
			
			const direction = new THREE.Vector3(
				projectileData.direction.x,
				projectileData.direction.y,
				projectileData.direction.z
			);
			
			const projectile = new Projectile(scene, position, direction, owner, collisionSystem);
			projectile.id = projectileData.id;
			
			// Utiliser les valeurs sp√©cifiques du projectile si fournies
			if (projectileData.damage) projectile.damage = projectileData.damage;
			if (projectileData.maxDistance) projectile.maxDistance = projectileData.maxDistance;
			
			// Si c'est un autre joueur qui tire, faire un effet visuel sur son canon
			if (otherPlayers[projectileData.ownerId]) {
				otherPlayers[projectileData.ownerId].showRecoilEffect();
			}
			// Stocker l'ID du projectile venant du serveur
			projectile.id = projectileData.id;
			console.log(`Projectile cr√©√©: ${projectileData.id} par joueur ${projectileData.ownerId}`);
			
			// Ajouter √† la liste des projectiles du propri√©taire seulement si le propri√©taire existe encore
			if (projectileData.ownerId === socket.id) {
				player.projectiles.push(projectile);
			} else if (otherPlayers[projectileData.ownerId]) {
				otherPlayers[projectileData.ownerId].projectiles.push(projectile);
			}
			// Ne pas stocker le projectile si le propri√©taire n'existe plus
		}
		
		// Cr√©er les √©l√©ments d'UI n√©cessaires au cycle de jeu
		function createGameCycleUI() {
			// Cr√©er l'horloge de jeu
			const gameClock = document.createElement('div');
			gameClock.id = 'game-clock';
			gameClock.className = 'game-clock';
			document.body.appendChild(gameClock);
			
			// Cr√©er l'√©cran de podium
			const podiumScreen = document.createElement('div');
			podiumScreen.id = 'podium-screen';
			podiumScreen.className = 'podium-screen';
			podiumScreen.style.display = 'none';
			document.body.appendChild(podiumScreen);
		}

		// Afficher le podium avec les gagnants
		function showPodium(winners) {
			// Supprimer l'ancien podium s'il existe
			const oldPodium = document.getElementById('podium-screen');
			if (oldPodium) {
				document.body.removeChild(oldPodium);
			}
			
			// Cr√©er l'√©cran de podium
			const podiumScreen = document.createElement('div');
			podiumScreen.id = 'podium-screen';
			podiumScreen.className = 'podium-screen';
			
			// Titre
			const title = document.createElement('h1');
			title.className = 'podium-title';
			title.textContent = "üèÜ Game over- Podium üèÜ";
			podiumScreen.appendChild(title);
			
			// Conteneur du podium
			const podiumContainer = document.createElement('div');
			podiumContainer.className = 'podium-container';
			
			// D√©finir l'ordre d'affichage et les caract√©ristiques
			const podiumConfig = [
				{ position: 0, index: 0, height: '280px', medal: 'ü•á', color: 'linear-gradient(to bottom, #FFD700, #FFA500)', title: '1er' },
				{ position: 1, index: 1, height: '220px', medal: 'ü•à', color: 'linear-gradient(to bottom, #C0C0C0, #A9A9A9)', title: '2√®me' },
				{ position: 2, index: 2, height: '180px', medal: 'ü•â', color: 'linear-gradient(to bottom, #CD7F32, #8B4513)', title: '3√®me' }
			];
			
			// Cr√©er chaque marche du podium
			podiumConfig.forEach(config => {
				const winner = winners[config.position];
				if (!winner) return; // Pas de joueur √† cette position
				
				const podiumStep = document.createElement('div');
				podiumStep.className = 'podium-step';
				podiumStep.style.width = '200px';
				podiumStep.style.height = '0px'; // D√©marrer √† 0 pour l'animation
				podiumStep.style.background = config.color;
				podiumStep.style.margin = '0 10px';
				
				// Avatar (utilise la premi√®re lettre du nom d'utilisateur)
				const avatar = document.createElement('div');
				avatar.className = 'podium-avatar';
				avatar.textContent = winner.username.charAt(0).toUpperCase();
				
				// Position
				const position = document.createElement('div');
				position.className = 'podium-position';
				position.textContent = config.medal;
				
				// Nom d'utilisateur
				const username = document.createElement('div');
				username.className = 'podium-username';
				username.textContent = winner.username;
				
				// Score
				const score = document.createElement('div');
				score.className = 'podium-score';
				score.textContent = `Score: ${winner.score} points`;
				
				// Ajouter les √©l√©ments √† la marche
				podiumStep.appendChild(position);
				podiumStep.appendChild(avatar);
				podiumStep.appendChild(username);
				podiumStep.appendChild(score);
				
				// Ajouter au conteneur
				podiumContainer.appendChild(podiumStep);
				
				// Animer apr√®s un court d√©lai (animation d'apparition)
				setTimeout(() => {
					podiumStep.style.height = config.height;
				}, 500 + config.index * 300);
			});
			
			podiumScreen.appendChild(podiumContainer);
			
			// Compteur de red√©marrage
			const restartCounter = document.createElement('div');
			restartCounter.id = 'restart-counter';
			restartCounter.className = 'restart-counter';
			podiumScreen.appendChild(restartCounter);
			
			// Ajouter √† la page
			document.body.appendChild(podiumScreen);
		}

		// Masquer le podium
		function hidePodium() {
			const podiumScreen = document.getElementById('podium-screen');
			if (podiumScreen) {
				podiumScreen.style.display = 'none';
			}
		}

		// D√©marrer un compte √† rebours
		function startCountdown(seconds, prefix) {
			const restartCounter = document.getElementById('restart-counter');
			if (!restartCounter) return;
			
			let remainingSeconds = Math.floor(seconds);
			
			const updateCounter = () => {
				restartCounter.textContent = `${prefix}: ${remainingSeconds}s`;
				
				if (remainingSeconds > 0) {
					remainingSeconds--;
					setTimeout(updateCounter, 1000);
				}
			};
			
			updateCounter();
		}

		// Variable globale pour stocker l'ID de l'animation de l'horloge
		let clockAnimationId = null;
		
		// Afficher l'horloge de la partie
		function showGameClock(endTime) {
		  const gameClock = document.getElementById('game-clock');
		  if (!gameClock) return;
		  
		  // Arr√™ter l'animation pr√©c√©dente si elle existe
		  if (clockAnimationId) {
			cancelAnimationFrame(clockAnimationId);
			clockAnimationId = null;
		  }
		  
		  gameClock.style.display = 'block';
		  gameClock.innerHTML = ""; // Vider le contenu pr√©c√©dent
		  
		  // Mettre √† jour l'horloge chaque seconde
		  const updateClock = () => {
			const now = Date.now();
			const timeLeft = endTime - now;
			
			if (timeLeft <= 0) {
			  gameClock.innerHTML = "<div class='game-info time-warning'>‚è±Ô∏è Fin de partie!</div>";
			  clockAnimationId = null;
			  return;
			}
			
			// Formater le temps restant
			const minutes = Math.floor(timeLeft / 60000);
			const seconds = Math.floor((timeLeft % 60000) / 1000);
			const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
			
			// Ajouter une classe d'alerte si moins de 5 minutes
			const isWarning = timeLeft < 1 * 60 * 1000;
			
			gameClock.innerHTML = `
			  <div class='game-info ${isWarning ? "time-warning" : ""}'>
				‚è±Ô∏è Time remaining: ${timeString}
			  </div>
			`;
			
			// Continuer √† mettre √† jour
			clockAnimationId = requestAnimationFrame(updateClock);
		  };
		  
		  updateClock();
		}

		// Afficher un message de red√©marrage
		function showRestartingMessage() {
			const notification = document.createElement('div');
			notification.style.position = 'absolute';
			notification.style.top = '50%';
			notification.style.left = '50%';
			notification.style.transform = 'translate(-50%, -50%)';
			notification.style.backgroundColor = 'rgba(200, 0, 0, 0.9)';
			notification.style.color = 'white';
			notification.style.padding = '30px 50px';
			notification.style.borderRadius = '10px';
			notification.style.fontSize = '32px';
			notification.style.fontWeight = 'bold';
			notification.style.zIndex = '3000';
			notification.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.7)';
			notification.style.textAlign = 'center';
			notification.style.animation = 'pulse 0.5s infinite alternate';
			notification.innerHTML = '‚ö†Ô∏è SERVER RESTART<br>Preparing new game....';
			
			// Ajouter l'animation
			const style = document.createElement('style');
			style.textContent = `
				@keyframes pulse {
					from { transform: translate(-50%, -50%) scale(1); }
					to { transform: translate(-50%, -50%) scale(1.05); }
				}
			`;
			document.head.appendChild(style);
			
			document.body.appendChild(notification);
			
			// Supprimer apr√®s quelques secondes
			setTimeout(() => {
				document.body.removeChild(notification);
				if (style.parentNode) {
					document.head.removeChild(style);
				}
			}, 4000);
		}

		// R√©initialiser l'interface utilisateur
		function resetUI() {
		  // R√©initialiser les statistiques
		  document.getElementById('hp').textContent = '100';
		  document.getElementById('maxhp').textContent = '100';
		  document.getElementById('atk').textContent = '10';
		  document.getElementById('def').textContent = '10';
		  document.getElementById('atkspeed').textContent = '0.5';
		  document.getElementById('range').textContent = '10';
		  document.getElementById('speed').textContent = '0.02';
		  document.getElementById('repair').textContent = '0.1';
		  document.getElementById('processors').textContent = '0';
		  
		  // Vider compl√®tement le leaderboard
		  const playersList = document.getElementById('players-list');
		  if (playersList) {
			playersList.innerHTML = '';
		  }
		  
		  // Vider √©galement la liste des autres joueurs en m√©moire
		  Object.keys(otherPlayers).forEach(id => {
			removeOtherPlayer(id);
		  });
		}

		// Mettre √† jour l'√©tat du jeu
		function updateGameState(newState) {
			// Supprimer tous les √©l√©ments de jeu existants
			
			// Arr√™ter toutes les animations en cours
			if (animationId) {
				cancelAnimationFrame(animationId);
				animationId = null;
			}
			// Supprimer les processeurs
			gameMap.processors.forEach(processor => {
				if (processor.isBouncing) {
					processor.isBouncing = false;  // Arr√™ter les animations de rebond
				}
				processor.destroy();
			});
			gameMap.processors = [];
			
			// Supprimer les canons
			gameMap.cannons.forEach(cannon => {
				if (cannon.isBouncing) {
					cannon.isBouncing = false;  // Arr√™ter les animations de rebond
				}
				cannon.destroy();
			});
			gameMap.cannons = [];
			
			// Nettoyer explicitement les projectiles de tous les joueurs
			Object.values(otherPlayers).forEach(otherPlayer => {
				otherPlayer.projectiles.forEach(projectile => {
					projectile.destroy();
				});
				otherPlayer.projectiles = [];
			});
			
			player.projectiles.forEach(projectile => {
				projectile.destroy();
			});
			player.projectiles = [];
			
			// Supprimer les structures
			gameMap.structures.forEach(structure => {
				if (structure.destroy) {
					structure.destroy();
				}
			});
			gameMap.structures = [];
			
			// Supprimer les autres joueurs
			Object.values(otherPlayers).forEach(otherPlayer => {
				removeOtherPlayer(otherPlayer.playerId);
			});
			
			// R√©initialiser le joueur principal
			player.hp = 100;
			player.maxHp = 100;
			player.resistance = 10;
			player.attack = 10;
			player.attackSpeed = 0.5;
			player.range = 10;
			player.speed = 0.02;
			player.repairSpeed = 0.5;
			player.baseScale = 1.0;
			player.processorCounts = {
				hp: 0,
				resistance: 0,
				attack: 0,
				attackSpeed: 0,
				range: 0,
				speed: 0,
				repairSpeed: 0
			};
			player.totalProcessors = 0;
			player.updateUI();
			player.setRandomPosition();
			player.isAlive = true;
			
			// Si le joueur √©tait invisible, le rendre visible √† nouveau
			player.mesh.visible = true;
			
			// Cr√©er les nouvelles structures et objets
			if (newState) {
				// Traiter les structures
				if (newState.structures) {
					Object.values(newState.structures).forEach(structureData => {
						createServerStructure(structureData);
					});
				}
				
				// Traiter les processeurs
				if (newState.processors) {
					Object.values(newState.processors).forEach(processorData => {
						createServerProcessor(processorData);
					});
				}
				
				// Traiter les canons
				if (newState.cannons) {
					Object.values(newState.cannons).forEach(cannonData => {
						createServerCannon(cannonData);
					});
				}
			}
			
			// √Ä la fin de updateGameState, nous devons red√©marrer l'animation
			// mais seulement si nous ne sommes pas sur l'√©cran de connexion
			if (gameStarted) {
				animationId = requestAnimationFrame(animate);
			}
			
		}

        // Boucle d'animation
        let lastTime = 0;
        let processorSpawnEnabled = true; // Variable pour activer/d√©sactiver l'apparition des processeurs

		function animate(time) {
			animationId = requestAnimationFrame(animate);
			
			// Convertir le temps en millisecondes et calculer le delta
			const currentTime = time;
			const deltaTime = (currentTime - lastTime) / 1000; // Convertir en secondes
			
			// V√©rifier si le joueur existe et si le jeu a commenc√©
			if (player && player.mesh && gameStarted) {
				// D√©placer le joueur selon les touches press√©es
				player.move(keys);
				
				// Mettre √† jour le tag du nom du joueur
				updatePlayerNameTag(player);
				
				// G√©rer les attaques
				player.doAttack(keys, currentTime);
				
				// R√©parer automatiquement le robot
				player.repair(deltaTime);
				
				// Mettre √† jour les processeurs sur la carte (sans en cr√©er de nouveaux)
				for (let i = gameMap.processors.length - 1; i >= 0; i--) {
					gameMap.processors[i].update();
				}
				
				// Mettre √† jour seulement les canons existants (sans en cr√©er de nouveaux)
				for (let i = gameMap.cannons.length - 1; i >= 0; i--) {
					gameMap.cannons[i].update();
				}
				
				// Mettre √† jour les autres joueurs
				for (const id in otherPlayers) {
					// R√©parer automatiquement
					otherPlayers[id].repair(deltaTime);
					
					// Mettre √† jour les projectiles
					otherPlayers[id].updateProjectiles();
					
					// Mettre √† jour le tag de nom
					updatePlayerNameTag(otherPlayers[id]);
				}
				
				// Mettre √† jour p√©riodiquement le tableau de score (1 fois par seconde)
				if (Math.floor(time / 1000) !== Math.floor(lastTime / 1000)) {
					updateScoreboard();
				}
				
				// Mettre √† jour la cam√©ra pour suivre le joueur
				if (cameraController) {
					updateCamera();
				}
			} else {
				// Si le joueur n'existe pas encore ou si le jeu n'a pas commenc√©,
				// on peut quand m√™me rendre la sc√®ne avec une cam√©ra statique
				camera.position.set(0, 30, 30);
				camera.lookAt(0, 0, 0);
				
				// On peut toujours animer certains √©l√©ments de la sc√®ne pour une apparence plus vivante
				// Par exemple, faire tourner les processeurs et les canons
				for (let i = gameMap.processors.length - 1; i >= 0; i--) {
					gameMap.processors[i].update();
				}
				
				for (let i = gameMap.cannons.length - 1; i >= 0; i--) {
					gameMap.cannons[i].update();
				}
			}
			
			// Rendu de la sc√®ne
			renderer.render(scene, camera);
			
			lastTime = currentTime;
		}
		
		function cleanupGame() {
			// Arr√™ter toutes les animations
			cancelAnimationFrame(animationId);
			
			// Nettoyer tous les objets avec des animations
			gameMap.processors.forEach(p => p.destroy());
			gameMap.cannons.forEach(c => c.destroy());
			gameMap.structures.forEach(s => { if (s.destroy) s.destroy(); });
			
			// Nettoyer les projectiles
			player.projectiles.forEach(p => p.destroy());
			Object.values(otherPlayers).forEach(op => {
				op.projectiles.forEach(p => p.destroy());
			});
			
			// Nettoyer les tags de noms
			removePlayerNameTag(player);
			Object.values(otherPlayers).forEach(op => removePlayerNameTag(op));
			
			// Supprimer les √©couteurs d'√©v√©nements
			document.removeEventListener('keydown', keydownHandler);
			document.removeEventListener('keyup', keyupHandler);
			window.removeEventListener('resize', resizeHandler);
			
			// D√©connecter du serveur
			socket.disconnect();
			
			console.log("Jeu nettoy√© avec succ√®s.");
		}

		// Ajouter un √©couteur d'√©v√©nement pour nettoyer avant de quitter
		window.addEventListener('beforeunload', cleanupGame);

		function createDamageText(position, amount) {
		    // Check if position is valid
			if (!position) {
				console.warn("Invalid position for damage text");
				return;
			}
			// Convertir la position 3D en position 2D sur l'√©cran
			const vector = position.clone();
			vector.project(camera); // Projeter la position 3D sur l'√©cran 2D
			
			// Convertir les coordonn√©es normalis√©es (-1 √† 1) en coordonn√©es de l'√©cran
			const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
			const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
			
			// Cr√©er l'√©l√©ment de texte
			const textElement = document.createElement('div');
			textElement.className = 'floating-text';
			
			// Ajouter un d√©calage vertical al√©atoire pour √©viter la superposition
			const verticalOffset = (Math.random() - 0.5) * 50;
			
			textElement.textContent = `-${amount}HP`;
			textElement.style.color = "#ff0000"; // Rouge pour les d√©g√¢ts
			textElement.style.left = x + 'px';
			textElement.style.top = (y + verticalOffset) + 'px';
			document.body.appendChild(textElement);
			
			// D√©marrer l'animation
			setTimeout(() => {
				textElement.style.opacity = '0';
				textElement.style.transform = 'translateY(-50px)';
			}, 10);
			
			// Supprimer l'√©l√©ment apr√®s l'animation
			setTimeout(() => {
				document.body.removeChild(textElement);
			}, 1000);
		}

        // Gestion du redimensionnement de la fen√™tre
		window.addEventListener('resize', () => {
			// Mise √† jour de la cam√©ra et du renderer (code existant)
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
			
			// Mise √† jour des tags de tous les joueurs
			if (player && player.nameTag) {
				updatePlayerNameTag(player);
			}
			
			for (const id in otherPlayers) {
				if (otherPlayers[id] && otherPlayers[id].nameTag) {
					updatePlayerNameTag(otherPlayers[id]);
				}
			}
		});

        // D√©marrer l'animation
        requestAnimationFrame(animate);
    </script>	
	<a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">üïπÔ∏è Vibe Jam 2025</a>
</body>
</html>
